local Archive = require("Kdm/Archive")
local Gear = require("Kdm/Gear")
local Check = require("Kdm/Util/Check")
local Container = require("Kdm/Util/Container")
local EventManager = require("Kdm/Util/EventManager")
local Location = require("Kdm/Location")
local log = require("Kdm/Log").ForModule("Player")
local NamedObject = require("Kdm/NamedObject")
local Survivor = require("Kdm/Survivor")
local Ui = require("Kdm/Ui")
local Util = require("Kdm/Util/Util")
local Weapon = require("Kdm/Weapon")

---------------------------------------------------------------------------------------------------

local Player = {}
Player.__index = Player
function Player.Is(x) return getmetatable(x) == Player end

Player.HIT_LOCATIONS = { "head", "arms", "body", "waist", "legs" }

Player.TOKENS = {
    ["Movement Token"] = true,
    ["Speed Token"] = true,
    ["Accuracy Token"] = true,
    ["Strength Token"] = true,
    ["Evasion Token"] = true,
    ["Luck Token"] = true,
    ["Bleeding Token"] = true,
    ["Lunacy Token"] = true,
    ["Reroll Token"] = true,
}

Player.TOKEN_STATS = {
    ["Movement Token"] = "movement",
    ["Speed Token"] = "speed",
    ["Accuracy Token"] = "accuracy",
    ["Strength Token"] = "strength",
    ["Evasion Token"] = "evasion",
    ["Luck Token"] = "luck",
    ["Lunacy Token"] = "frenzy",
}

---------------------------------------------------------------------------------------------------

function Player.Init(saveState)
    Player.players = {}
    for ordinal = 1, 4 do
        Player.players[ordinal] = Player.Create(ordinal, saveState[ordinal] or {})
    end
end

---------------------------------------------------------------------------------------------------

function Player.PostInit()
    for _, player in ipairs(Player.players) do
        player:UpdateGear()
        player:UpdateStats()
    end

    EventManager.AddHandler("onObjectCollisionEnter", Player.OnObjectCollisionEnter)
    EventManager.AddHandler("onObjectEnterContainer", Player.OnObjectEnterContainer)
    EventManager.AddHandler("onObjectDestroy", Player.OnObjectDestroy)
    EventManager.AddHandler(EventManager.ON_SURVIVOR_STAT_CHANGED, Player.OnSurvivorChangeStat)
    EventManager.AddHandler(EventManager.ON_PLAYER_COLOR_CHANGED, Player.OnPlayerColorChanged)

    Wait.time(function()
        for ordinal, player in ipairs(Player.players) do
            local playerMarker = NamedObject.Get("Player "..ordinal.." Marker")
            if playerMarker then
                local colorTable = playerMarker.getColorTint()
                local colorStr = "#"..Color(colorTable):toHex()
                EventManager.FireEvent(EventManager.ON_PLAYER_COLOR_CHANGED, player, colorTable, colorStr)
            end
        end
    end, 2, -1)
end

---------------------------------------------------------------------------------------------------

function Player.Save()
    local saveState = {}
    for i, player in ipairs(Player.players) do
        local playerSaveState = {}

        if player.survivorSheet then
            playerSaveState.survivorSheetGuid = player.survivorSheet:Object().getGUID()
        end

        if player.figurineObject then
            playerSaveState.figurineGuid = player.figurineObject.getGUID()
        end

        playerSaveState.temporaryArmor = player.temporaryArmor
--        playerSaveState.injuries = player.injuries
        playerSaveState.lightInjuries = player.lightInjuries
        playerSaveState.heavyInjuries = player.heavyInjuries

        table.insert(saveState, playerSaveState)
    end
    return saveState
end

---------------------------------------------------------------------------------------------------

function Player.ForFigurine(figurineObject)
    for _, player in ipairs(Player.players) do
        if player.figurineObject == figurineObject then
            return player
        end
    end
end

---------------------------------------------------------------------------------------------------

function Player.ForPortrait(portraitObject)
    for _, player in ipairs(Player.players) do
        if player.portraitObject == portraitObject then
            return player
        end
    end
end

---------------------------------------------------------------------------------------------------

function Player.ForBingo(bingoObject)
    for _, player in ipairs(Player.players) do
        if player.bingoObject == bingoObject then
            return player
        end
    end
end

---------------------------------------------------------------------------------------------------

function Player.OnObjectCollisionEnter(object, collisionInfo)
    -- This is a hack to detect flipped tokens
    -- There's no onFlip event, and flipping doesn't trigger onPickUp, so we rely on this to detect flips
    -- of *already registered* tokens.

    local collisionObject = collisionInfo.collision_object

    local player = nil
    for _, p in ipairs(Player.players) do
        if p.boardObject == collisionObject then
            player = p
            break
        end
    end
    if not player then
        return
    end

    log:Debugf("[%s]%s collided with [%s]%s", object.getGUID(), object.getName(), collisionObject.getGUID(), collisionObject.getName())

    local playerPrefix = "Player "..player.ordinal
    local temporaryTokensLocation = Location.Get(playerPrefix.." Temporary Tokens")
    local permanentTokensLocation = Location.Get(playerPrefix.." Permanent Tokens")
    local gearLocation = Location.Get(playerPrefix.." Gear")

    for _, location in ipairs(Location.ObjectLocations(object)) do
        if location == temporaryTokensLocation or location == permanentTokensLocation then
            log:Debugf("Token [%s]%s found in %s, updating stats", object.getGUID(), object.getName(), location)
            player:UpdateStats()
            break
        elseif location == gearLocation then
            log:Debugf("Token [%s]%s found in %s, updating gear", object.getGUID(), object.getName(), location)
            player:UpdateGear()
            player:UpdateStats()
            break
        end
    end
end

---------------------------------------------------------------------------------------------------

function Player.OnObjectEnterContainer(container, object)
    local player = Player.ForFigurine(object)
    if player then
        player:UnlinkFigurine(object)
    end
    local player2 = Player.ForPortrait(object)
    if player2 then
        player2.survivorSheet:Survivor().SetPortraitJSON(object.getJSON())
        player2:UnlinkPortrait(object)
    end
    local player3 = Player.ForBingo(object)
    if player3 then
        player3.survivorSheet:Survivor().SetBingoJSON(object.getJSON())
        player3:UnlinkBingo(object)
    end
end

---------------------------------------------------------------------------------------------------

function Player.OnObjectDestroy(object)
    for _, player in ipairs(Player.players) do
        if player.survivorSheet and player.survivorSheet:Object() == object then
            player:UnlinkSurvivorSheet()
            break
        end
    end

    local player = Player.ForFigurine(object)
    if player then
        player:UnlinkFigurine(object)
    end
    local player2 = Player.ForPortrait(object)
    if player2 then
        player2.survivorSheet:Survivor().SetPortraitJSON(object.getJSON())
        player2:UnlinkPortrait(object)
    end
    local player3 = Player.ForBingo(object)
    if player3 then
        player3.survivorSheet:Survivor().SetBingoJSON(object.getJSON())
        player3:UnlinkBingo(object)
    end    
end

---------------------------------------------------------------------------------------------------

function Player.OnSurvivorChangeStat(survivor, stat, value)
    if stat == "name" then
        for _, player in ipairs(Player.players) do
            if player.survivorSheet and player.survivorSheet:Survivor() == survivor then
                if player.figurineObject then
                    log:Debugf("Updating figurine [%s] name for %s to %s", player.figurineObject.getGUID(), player, value)
                    player.figurineObject.setName(value)
                end
                if player.portraitObject then
                    log:Debugf("Updating portrait [%s] name for %s to %s", player.figurineObject.getGUID(), player, value)
                    player.portraitObject.setName(value)
                end
                if player.bingoObject then
                    log:Debugf("Updating bingo card [%s] name for %s to %s", player.bingoObject.getGUID(), player, value)
                    player.bingoObject.setName(value .. "'s Bingo")
                end
            end
        end
    end
end

---------------------------------------------------------------------------------------------------

function Player.OnPlayerColorChanged(player, colorTable, colorStr)
    if player.figurineObject then
        player.figurineObject.setColorTint(colorTable)
    end
--    if player.portraitObject then
--        player.portraitObject.setColorTint(colorTable)
--    end
    if player.bingoObject then
        player.bingoObject.editButton({
            index = 24,
            color = colorTable,
        })
        player.bingoObject.call("onSave")
    end
end

---------------------------------------------------------------------------------------------------

function Player.Create(ordinal, params)
    local playerPrefix = "Player "..ordinal

    local player = {
        tag = "Player",
        ordinal = ordinal,
        boardObject = NamedObject.Get(playerPrefix.." Board"),
        markerObject = NamedObject.Get(playerPrefix.." Marker"),
        weapons = {},   -- purely a concession to make BattleUi updates easier
    }
    setmetatable(player, Player)

    local playerPrefix = "Player "..player.ordinal

    if params.survivorSheetGuid then
        local survivorSheetObject = getObjectFromGUID(params.survivorSheetGuid)
        if survivorSheetObject == nil then  -- compare nil for TTS objects
            log:Errorf("Can't find survivor sheet %s that %d was linked to! Try recreating the it from the Population screen and dropping it back onto the player board.", params.linkedSurvivorSheetGuid, ordinal)
        else
            player.survivorSheet = Survivor.SurvivorSheetForObject(survivorSheetObject)
            if not player.survivorSheet then
                log:Errorf("Survivor sheet %s on player board %d wasn't linked to any survivor.", survivorSheetObject.getGUID(), ordinal)
            else
                log:Debugf("Linked %s to %s", player.survivorSheet, player)
            end
        end
    end

    if params.figurineGuid then
        local figurineObject = getObjectFromGUID(params.figurineGuid)
        if not figurineObject then
            log:Errorf("Player %s was linked to figurine %s, but that object was deleted.", ordinal, params.figurineGuid)
        else
            player:LinkFigurine(figurineObject)
        end
    end

    player.temporaryArmor = {}
    player.lightInjuries = {}
    player.heavyInjuries = {}
    local paramsTemporaryArmor = params.temporaryArmor or {}
    local paramsLightInjuries = params.lightInjuries or {}
    local paramsHeavyInjuries = params.heavyInjuries or {}
    for _, hitLocation in ipairs(Player.HIT_LOCATIONS) do
        player.temporaryArmor[hitLocation] = paramsTemporaryArmor[hitLocation] or 0
        player.lightInjuries[hitLocation] = paramsLightInjuries[hitLocation]
        player.heavyInjuries[hitLocation] = paramsHeavyInjuries[hitLocation]
    end

    player.gear = {}
    local playerGearPrefix = playerPrefix.." Gear "
    for i = 1, 9 do
        player.gear[Location.Get(playerGearPrefix..i)] = {
            weapon = nil,
            armor = nil,
            tokens = {},
        }
    end
    player.gear[Location.Get(playerPrefix.." Fist & Tooth")] = {
        weapon = nil,
        armor = nil,
        tokens = {},
    }

    player:InitUi()

    local playerPrefix = "Player "..player.ordinal

    Location.Get(playerPrefix.." Survivor Sheet"):AddDropHandler(function(object)
        player:OnObjectDroppedOnSurvivorSheet(object)
    end)

    Location.Get(playerPrefix.." Marker"):AddDropHandler(function(object)
        local type = object.getGMNotes()
        if type == "Player Figurine" then
            player:LinkFigurine(object)
        end
        if type == "Portrait" then
            player:LinkPortrait(object)
        end
        if type == "Bingo Card" then
            player:LinkBingo(object)
        end
    end)

    local checkUnregisterCollisions = function(object)
        if object and object.getGMNotes() == "Tokens" and Player.TOKEN_STATS[object.getName()] then
            log:Debugf("Unregistering token [%s]%s for collisions", object.getGUID(), object.getName())
            object.unregisterCollisions()
        end
    end

    local gearLocation = Location.Get(playerPrefix.." Gear")
    gearLocation:AddDropHandler(function(object, location)
        player:UpdateGear(object)
        player:UpdateCards()
    end)
    gearLocation:AddPickUpHandler(function(object, location)
        checkUnregisterCollisions(object)
        player:UpdateGear(object)
        player:UpdateCards()
    end)

    local cardsLocation = Location.Get(playerPrefix.." Cards")
    cardsLocation:AddDropHandler(function(object)
        player:UpdateCards()
    end)
    cardsLocation:AddPickUpHandler(function(object)
        player:UpdateCards()
    end)

    local temporaryTokensLocation = Location.Get(playerPrefix.." Temporary Tokens")
    temporaryTokensLocation:AddDropHandler(function(object)
        player:UpdateStats()
    end)
    temporaryTokensLocation:AddPickUpHandler(function(object)
        checkUnregisterCollisions(object)
        player:UpdateStats()
    end)

    local permanentTokensLocation = Location.Get(playerPrefix.." Permanent Tokens")
    permanentTokensLocation:AddDropHandler(function(object)
        player:UpdateStats()
    end)
    permanentTokensLocation:AddPickUpHandler(function(object)
        checkUnregisterCollisions(object)
        player:UpdateStats()
    end)

    return player
end

---------------------------------------------------------------------------------------------------

function Player.InitUi(player)
    local ui = Ui.Create3d("Player"..player.ordinal, player.boardObject, 0.11)
    player.ui = ui

    local x1 = -0.120503
    local y1 = -0.971472
    local x2 = -0.257252
    local y2 = -0.838162
    local xn = -0.842982
    local width = x2 - x1
    local dx = (xn - x1) / 4
    player.armorCounters = {}
    for i, hitLocation in ipairs(Player.HIT_LOCATIONS) do
        local topLeft = { x = x1 + (i - 1) * dx, y = y1 }
        local bottomRight = { x = topLeft.x + width, y = y2 }
        player.armorCounters[hitLocation] = ui:Counter({ id = hitLocation.."Armor", topLeft = topLeft, bottomRight = bottomRight, fontSize = 95, onValueChanged = function(delta)
            player.temporaryArmor[hitLocation] = player.temporaryArmor[hitLocation] + delta
            player:UpdateGear()
        end })
    end

    player.lightInjuryCheckBoxes = {}
    local x1 = -0.314098
    local y1 = -0.775458
    local x2 = -0.363223
    local y2 = -0.723353
    local xn = -0.855320
    local width = x2 - x1
    local dx = (xn - x1) / 3
    for i, hitLocation in ipairs({ "arms", "body", "waist", "legs" }) do
        local topLeft = { x = x1 + (i - 1) * dx, y = y1 }
        local bottomRight = { x = topLeft.x + width, y = y2 }
        player.lightInjuryCheckBoxes[hitLocation] = ui:CheckBox({ id = hitLocation.."LightInjury", topLeft = topLeft, bottomRight = bottomRight, checked = player.lightInjuries[hitLocation], onClick = function()
            local value = not player.lightInjuries[hitLocation]
            player.lightInjuries[hitLocation] = value
            player.lightInjuryCheckBoxes[hitLocation]:Check(value)
        end })
    end

    local x1 = -0.166245
    player.heavyInjuryCheckBoxes = {}
    player.heavyInjuryCheckBoxes.head = ui:CheckBox({ id = "headHeavyInjury", topLeft = { x = x1, y = y1 }, bottomRight = { x = x1 + width, y = y2 }, checked = player.heavyInjuries.head, onClick = function()
        local value = not player.heavyInjuries.head
        player.heavyInjuries.head = value
        player.heavyInjuryCheckBoxes.head:Check(value)
    end })
    local x1 = -0.376100
    local xn = -0.918347
    local dx = (xn - x1) / 3
    for i, hitLocation in ipairs({ "arms", "body", "waist", "legs" }) do
         local topLeft = { x = x1 + (i - 1) * dx, y = y1 }
        local bottomRight = { x = topLeft.x + width, y = y2 }
        player.heavyInjuryCheckBoxes[hitLocation] = ui:CheckBox({ id = hitLocation.."HeavyInjury", topLeft = topLeft, bottomRight = bottomRight, checked = player.heavyInjuries[hitLocation], onClick = function()
            local value = not player.heavyInjuries[hitLocation]
            player.heavyInjuries[hitLocation] = value
            player.heavyInjuryCheckBoxes[hitLocation]:Check(value)
        end })
    end

    ui:Button({ id = "healAndReset", topLeft = { x = -0.124014, y = -0.687478 }, bottomRight = { x = -0.323673, y = -0.596463 }, onClick = function()
        player:HealAndReset()
    end })

    ui:Button({ id = "backToSettlement", topLeft = { x = 0.910594, y = -0.139250 }, bottomRight = { x = 0.707226, y = -0.048424 }, onClick = function()
        player:BackToSettlement()
    end })

    ui:ApplyToObject()

    return player
end

---------------------------------------------------------------------------------------------------

function Player:__tostring()
    return Util.SafeFormat("Player{ordinal=%s}", self.ordinal)
end

---------------------------------------------------------------------------------------------------

function Player:Ordinal() return self.ordinal end
function Player:SurvivorSheet() return self.survivorSheet end

---------------------------------------------------------------------------------------------------

function Player:UpdateGear()
    local weaponsAndModifiers = {}

    local armorTotals = {}
    for _, hitLocation in ipairs(Player.HIT_LOCATIONS) do
        armorTotals[hitLocation] = self.temporaryArmor[hitLocation]
    end

    local playerPrefix = "Player "..self.ordinal
    for _, location in ipairs({
        playerPrefix.." Gear 1",
        playerPrefix.." Gear 2",
        playerPrefix.." Gear 3",
        playerPrefix.." Gear 4",
        playerPrefix.." Gear 5",
        playerPrefix.." Gear 6",
        playerPrefix.." Gear 7",
        playerPrefix.." Gear 8",
        playerPrefix.." Gear 9",
        playerPrefix.." Fist & Tooth",
        playerPrefix.." Armor Set",
    }) do
        local weaponAndModifiers = {
            weapon = nil,
            modifiers = {},
        }

        for _, object in ipairs(Location.Get(location):AllObjects()) do
            local objectName = object.GetName()
            if object.tag == "Card" then
                local object = Gear.getByName(objectName)
                if not object then
                    goto continue
                end
                log:Debugf("Checking gear %s at %s", objectName, location)
                if object.stats.isArmor then
                    log:Debugf("Adding armor %s at %s", objectName, location)
                    for _, hitLocation in ipairs(Player.HIT_LOCATIONS) do
                        armorTotals[hitLocation] = armorTotals[hitLocation] + object.stats[hitLocation]
                    end
                end

                if object.stats.isWeapon then
                    log:Debugf("Adding weapon %s at %s", objectName, location)
                    weaponAndModifiers.weapon = object
                end
            else
                local stat = Player.TOKEN_STATS[objectName]
                if stat then
                    log:Debugf("Adding token %s for weapon at %s", objectName, location)
                    weaponAndModifiers.modifiers[stat] = (weaponAndModifiers.modifiers[stat] or 0) + Util.TokenValue(object)
                    object.registerCollisions()
                end
            end
            ::continue::
        end

        if weaponAndModifiers.weapon then
            table.insert(weaponsAndModifiers, weaponAndModifiers)
        end
    end

    log:Debugf("Final %s weapons: %s", self, Util.TabStr(weaponsAndModifiers))
    log:Debugf("Final %s armor: %s", self, Util.TabStr(armorTotals))

    self.weaponsAndModifiers = weaponsAndModifiers    -- purely a concession to make BattleUi updates easier

    for _, hitLocation in ipairs(Player.HIT_LOCATIONS) do
        self.armorCounters[hitLocation]:SetText(armorTotals[hitLocation])
    end

    EventManager.FireEvent(EventManager.ON_PLAYER_WEAPONS_CHANGED, self, weaponsAndModifiers)
end

function Player:WeaponsAndModifiers() return self.weaponsAndModifiers end

---------------------------------------------------------------------------------------------------

function Player:UpdateCards()
    if not self.survivorSheet then
        return
    end

    log:Debugf("Updating %s cards", self)

    local cards = {}
    local positionsByCardNameType = {}
    for _, object in ipairs(Location.Get("Player "..self.ordinal.." Cards"):AllObjects()) do
        if object.tag == "Card" or object.tag == "Deck" then
            local container = Container(object)
            for _, card in ipairs(container:Objects()) do
                if Survivor.ALLOWED_CARD_TYPES[card.gm_notes] then
                    table.insert(cards, {
                        name = card.name,
                        type = card.gm_notes,
                    })

                    local nameType = (card.name or "")..card.gm_notes
                    local worldPosition = container:Object().getPosition()
                    local localPosition = self.boardObject.positionToLocal(worldPosition)
                    log:Debugf("Found card %s at world (%f, %f %f), local (%f, %f, %f)", card.name, worldPosition.x, worldPosition.y, worldPosition.z, localPosition.x, localPosition.y, localPosition.z)
                    if positionsByCardNameType[nameType] then
                        table.insert(positionsByCardNameType[nameType], localPosition)
                    else
                        positionsByCardNameType[nameType] = { localPosition }
                    end
                end
            end
        end
    end

    for _, object in ipairs(Location.Get("Player "..self.ordinal.." Gear"):AllObjects()) do
        if object.tag == "Card" or object.tag == "Deck" then
            local container = Container(object)
            for _, card in ipairs(container:Objects()) do
                if card.gm_notes == "Gear" then
                    local gear = Gear.getByName(card.name)
                    if gear and gear.stats.cursed then
                        table.insert(cards, {
                            name = card.name,
                            type = card.gm_notes,
                        })

                        local nameType = (card.name or "") .. card.gm_notes
                        local worldPosition = container:Object().getPosition()
                        local localPosition = self.boardObject.positionToLocal(worldPosition)
                        log:Debugf("Found card %s at world (%f, %f %f), local (%f, %f, %f)", card.name, worldPosition.x,
                            worldPosition.y, worldPosition.z, localPosition.x, localPosition.y, localPosition.z)
                        if positionsByCardNameType[nameType] then
                            table.insert(positionsByCardNameType[nameType], localPosition)
                        else
                            positionsByCardNameType[nameType] = { localPosition }
                        end
                    end
                end
            end
        end
    end

    self.survivorSheet:Survivor():SetCards(cards)
    self.survivorSheet:Survivor():SetPositionsByCardNameType(positionsByCardNameType)
end

---------------------------------------------------------------------------------------------------

function Player:UpdateStats()
    if not self.survivorSheet then
        return
    end

    local modifiers = {}
    for _, object in ipairs(Location.Get("Player "..self.ordinal.." Temporary Tokens"):AllObjects()) do
        if object.getGMNotes() == "Tokens" then
            local stat = Player.TOKEN_STATS[object.getName()]
            if stat then
                local value = Util.TokenValue(object)
                log:Debugf("Found temporary token %s=%d for player %s", object.getName(), value, self)
                modifiers[stat] = (modifiers[stat] or 0) + value
                object.registerCollisions()
            end
        end
    end

    for _, object in ipairs(Location.Get("Player "..self.ordinal.." Permanent Tokens"):AllObjects()) do
        if object.getGMNotes() == "Tokens" then
            local stat = Player.TOKEN_STATS[object.getName()]
            if stat then
                local value = Util.TokenValue(object)
                log:Debugf("Found permanent token %s=%d for player %s", object.getName(), value, self)
                modifiers[stat] = (modifiers[stat] or 0) + value
                object.registerCollisions()
            end
        end
    end

    local playerPrefix = "Player "..self.ordinal
    for _, location in ipairs({
        playerPrefix.." Gear 1",
        playerPrefix.." Gear 2",
        playerPrefix.." Gear 3",
        playerPrefix.." Gear 4",
        playerPrefix.." Gear 5",
        playerPrefix.." Gear 6",
        playerPrefix.." Gear 7",
        playerPrefix.." Gear 8",
        playerPrefix.." Gear 9",
        playerPrefix.." Fist & Tooth",
        playerPrefix.." Armor Set",
    }) do

        for _, object in ipairs(Location.Get(location):AllObjects()) do
            if object.tag ~= "Card" then
                local stat = Player.TOKEN_STATS[object.getName()]
                if stat == "evasion" then
                    local value = Util.TokenValue(object)
                    log:Debugf("Adding token %s from gear at %s", object.getName(), location)
                    modifiers[stat] = (modifiers[stat] or 0) + value
                    object.registerCollisions()
                end
            end
        end
    end

    self.survivorSheet:Survivor():SetModifiers(modifiers)
end

---------------------------------------------------------------------------------------------------

function Player:HealAndReset()
    -- Clear temporary armor
    for i, hitLocation in ipairs(Player.HIT_LOCATIONS) do
        self.temporaryArmor[hitLocation] = 0
    end
    self:UpdateGear()

    -- Clear injuries
    for i, hitLocation in ipairs({ "arms", "body", "waist", "legs" }) do
        self.lightInjuries[hitLocation] = nil
        self.lightInjuryCheckBoxes[hitLocation]:Check(nil)
    end
    for i, hitLocation in ipairs(Player.HIT_LOCATIONS) do
        self.heavyInjuries[hitLocation] = nil
        self.heavyInjuryCheckBoxes[hitLocation]:Check(nil)
    end

    -- Clear temporary tokens
    for _, object in ipairs(Location.Get("Player "..self.ordinal.." Temporary Tokens"):AllObjects("Tokens")) do
        if object.getGMNotes() == "Tokens" and Player.TOKENS[object.getName()] then
            object.destruct()
        end
    end

    -- Reset survivor sheet
    if self.survivorSheet then
        local survivor = self.survivorSheet:Survivor()
        survivor:SetModifiers()
        survivor:SetBrainInjury(nil)
    end

    -- Recalculate stats to take permanent tokens into account (From @ScottMahoney on Github.com, Full name Scott Mahoney?)
    self:UpdateStats()
end


---------------------------------------------------------------------------------------------------

function Player:OnObjectDroppedOnSurvivorSheet(object)
    if object.getGMNotes() ~= "Survivor Box" then
        return
    end

    if self.survivorSheet then
        return log:Broadcastf("Player %d is already linked to a survivor. Click the 'Back to Settlement' button to unlink, then try dropping the survivor box again.", self.ordinal)
    end

    local survivorBox = Survivor.SurvivorBoxForObject(object)
    if not survivorBox then
        return log:Errorf("Survivor box %s isn't linked to any survivor. This usually means it was created by copying/pasting or importing from another save, which won't work. If this is the case, then you'll need to create the survivor from the 'Survivors' board.", object.getGUID())
    end

    self:UnpackSurvivorBox(survivorBox)
end

---------------------------------------------------------------------------------------------------

function Player:UnpackSurvivorBox(survivorBox)
    log:Debugf("Unpacking %s for %s", survivorBox, self)

    local playerPrefix = "Player "..self.ordinal

    local blockingObjects = Location.Get(playerPrefix.." Cards"):AllObjects()
    if #blockingObjects > 0 then
        log:Printf("Please clear the cards area then re-drop the survivor box.")
        Util.HighlightAll(blockingObjects)
        return false
    end

    local survivor = survivorBox:Survivor()

    local countsByCardNameType = {}
    for _, card in ipairs(survivor:Cards()) do
        local nameType = card.name..card.type
        countsByCardNameType[nameType] = (countsByCardNameType[nameType] or 0) + 1
    end

    -- make a copy since we'll modify this
    local positionsByCardNameType = {}
    for cardName, positions in pairs(survivor:PositionsByCardNameType()) do
        positionsByCardNameType[cardName] = Util.CopyArray(positions)
    end

    local availableLocations = {
        [Location.Get(playerPrefix.." Fighting Art 1")] = true,
        [Location.Get(playerPrefix.." Fighting Art 2")] = true,
        [Location.Get(playerPrefix.." Fighting Art 3")] = true,
        [Location.Get(playerPrefix.." Disorder 1")] = true,
        [Location.Get(playerPrefix.." Disorder 2")] = true,
        [Location.Get(playerPrefix.." Disorder 3")] = true,
        [Location.Get(playerPrefix.." Weapon Proficiency")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 1")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 2")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 3")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 4")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 5")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 6")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 7")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 8")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 9")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 10")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 11")] = true,
    }

    local survivorBoxContainer = Container(survivorBox:Object())

    for _, entry in ipairs(survivorBoxContainer:Objects()) do
        if entry.gm_notes == "Player Figurine" then
            log:Debugf("Unpacking figurine %s to self marker", entry.guid)
            local figurineObject = survivorBoxContainer:Take({
                guid = entry.guid,
                location = playerPrefix.." Marker",
                spawnFunc = function(figurineObj)
                    self:LinkFigurine(figurineObj)
                end,
            })
            
        elseif entry.gm_notes == "Bingo Card" then
            log:Debugf("Unpacking bingo card %s to self bingo card", entry.guid)
            local bingoCardObject = survivorBoxContainer:Take({
                guid = entry.guid,
                location = playerPrefix.." Bingo",
                spawnFunc = function(bingoObj)
                    local waitId = nil
                    waitId = Wait.time(function()
                        if bingoObj.getButtons() then
                            Wait.stop(waitId)
                            self:LinkBingo(bingoObj)
                        end
                    end, 0.5, 5)
                end,
            })
        elseif entry.gm_notes == "Portrait" then
            log:Debugf("Unpacking portrait %s to self portrait", entry.guid)
            local portraitObject = survivorBoxContainer:Take({
                guid = entry.guid,
                location = playerPrefix.." Portrait",
                spawnFunc = function(portraitObj)
                    self:LinkPortrait(portraitObj)
                    portraitObj.setLock(true)
                end,
            })
        else
            local nameType = (entry.name or "")..(entry.gm_notes or "")
            if (countsByCardNameType[nameType] or 0) > 0 then
                countsByCardNameType[nameType] = countsByCardNameType[nameType] - 1

                local position = nil
                local count = #(positionsByCardNameType[nameType] or {})
                if count > 0 then
                    position = self.boardObject.positionToWorld(positionsByCardNameType[nameType][count])
                    table.remove(positionsByCardNameType[nameType])

                    log:Debugf("Unpacking card %s/%s to (%f, %f, %f)", entry.name, entry.gm_notes, position.x, position.y, position.z)
                    survivorBoxContainer:Take({
                        guid = entry.guid,
                        position = position,
                        rotation = { x = 0, y = 180, z = 0 },
                    })

                    for _, location in ipairs(Location.LocationsAtPosition(position)) do
                        log:Debugf("Card %s/%s now occupies %s", entry.name, entry.gm_notes, location)
                        availableLocations[location] = nil
                    end
                else
                    log:Debugf("Card %s doesn't have position", entry.name)
                end
            else
                log:Debugf("Unrecognized object in %s: %s/%s", survivorBox, entry.name, entry.gm_notes)
            end
        end
    end

    local overflowLocation = Location.Get(playerPrefix.." Ability/Impairment 11")
    local extraObjects = false
    local height = 2 + 0.5
    for _, entry in ipairs(survivorBoxContainer:Objects()) do
        local location = Player:TakeNextLocation(playerPrefix, entry.gm_notes, availableLocations)
        if not location then
            log:Errorf("No more space to place %s separately!", entry.name)
            location = overflowLocation
            extraObjects = true
        end

        log:Debugf("Taking %s (%s) to %s", entry.name, entry.guid, location)
        survivorBoxContainer:Take({
            guid     = entry.guid,
            location = location,
            height   = height,
        })
        height = height + 0.5
    end

    if extraObjects then
        log:Errorf("Some items couldn't be placed separately and have been stacked on the lower-right card slot of your survivor sheet.")
        overflowLocation:BoxCast({ debug = true })
    end

    local survivorSheet = Survivor.SurvivorSheetForSurvivor(survivorBox:Survivor())
    if survivorSheet then
        log:Debugf("%s already exists, destroying and recreating", survivorSheet)
        survivorSheet:Object().destruct()
    end

    Archive.Take({ name = "Survivor Sheet", type = "Survivor Sheet", location = playerPrefix.." Survivor Sheet", height = 0, rotation = { x = 0, y = 180, z = 0 }, spawnFunc = function(survivorSheetObject)
        -- We have to wait a single frame when taking from an infinite container or the objects will have the same equality/identity value as any other objects taken that frame
        Wait.frames(function()
            log:Debugf("Created survivor sheet for object %s and %s", survivorSheetObject.getGUID(), survivorBox:Survivor())
            local survivorSheet = Survivor.CreateSurvivorSheet(survivorBox:Survivor(), survivorSheetObject)
            survivorSheetObject.setLock(true)
            survivorBox:Object().destruct()
            self:LinkSurvivorSheet(survivorSheet)
        end, 1)
    end })

    EventManager.FireEvent(EventManager.ON_SURVIVOR_GETS_IN_PLAY, survivor)

    return true
end

---------------------------------------------------------------------------------------------------

function Player:TakeNextLocation(playerPrefix, gmNotes, availableLocations)
    if gmNotes == "Disorders" then
        for i = 1, 3 do
            local key = Location.Get(playerPrefix.." Disorder "..i)
            if availableLocations[key] then
                availableLocations[key] = nil
                return key
            end
        end

    elseif gmNotes == "Fighting Arts" or gmNotes == "Secret Fighting Arts" then
        for i = 1, 3 do
            local key = Location.Get(playerPrefix.." Fighting Art "..i)
            if availableLocations[key] then
                availableLocations[key] = nil
                return key
            end
        end

    elseif gmNotes == "Weapon Proficiencies" then
        local key = Location.Get(playerPrefix.." Weapon Proficiency")
        if availableLocations[key] then
            availableLocations[key] = nil
            return key
        end
    end

    for i = 1, 11 do
        local key = Location.Get(playerPrefix.." Ability/Impairment "..i)
        if availableLocations[key] then
            availableLocations[key] = nil
            return key
        end
    end
end

---------------------------------------------------------------------------------------------------

function Player:LinkSurvivorSheet(survivorSheet)
    assert(Check(self.survivorSheet == nil, "%s is already linked to %s", self, self.survivorSheet))

    log:Debugf("Linking %s to %s", survivorSheet, self)

    self.survivorSheet = survivorSheet
    if self.figurineObject then
        local name = survivorSheet:Survivor():NameOrUnnamed()
        log:Debugf("Setting linked figurine %s name to %s", self.figurineObject.getGUID(), name)
        self.figurineObject.setName(name)
    end

    if self.portraitObject then
        local name = survivorSheet:Survivor():NameOrUnnamed()
        log:Debugf("Setting linked portrait %s name to %s", self.portraitObject.getGUID(), name)
        self.portraitObject.setName(name)
    end

    if self.bingoObject then
        local name = survivorSheet:Survivor():NameOrUnnamed()
        log:Debugf("Setting linked bingo %s name to %s", self.bingoObject.getGUID(), name)
        self.bingoObject.setName(name  ..  "'s Bingo")
    end

    Wait.frames(function()
        -- the survivor sheet object may have been created this turn, in which case we must wait X frames
        -- before updating any XML UI elements
        self:UpdateStats()
    end, 20)

    self:UpdateCards()

    EventManager.FireEvent(EventManager.ON_PLAYER_SURVIVOR_LINKED, self, survivorSheet:Survivor())
end

---------------------------------------------------------------------------------------------------

function Player:UnlinkSurvivorSheet()
    local survivorSheet = self.survivorSheet
    local survivor = survivorSheet:Survivor()
    log:Debugf("Unlinking %s from %s", survivorSheet, self)
    survivor:SetModifiers()
    self.survivorSheet = nil
    EventManager.FireEvent(EventManager.ON_PLAYER_SURVIVOR_UNLINKED, self, survivor)
end

---------------------------------------------------------------------------------------------------

function Player:BackToSettlement()
    local survivorSheet = self.survivorSheet
    if survivorSheet == nil then
        return log:Debugf("No survivor linked with %s", self)
    end

    local survivor = survivorSheet:Survivor()

    log:Debugf("Returning %s on %s to settlement", survivorSheet, self)

    if self:PortraitObject() then
        self.survivorSheet:Survivor():SetPortraitJSON(self:PortraitObject().getJSON())
    end

    if self:BingoObject() then
        self.survivorSheet:Survivor():SetBingoJSON(self:BingoObject().getJSON())
    end

    self:UnlinkSurvivorSheet()

    local remainingObjects = {}
    for _, object in ipairs(Location.Get("Player "..self.ordinal.." Cards"):AllObjects()) do
        if object.tag == "Card" or object.tag == "Deck" then
            local container = Container(object)
            local toDelete = {}
            for _, entry in ipairs(container:Objects()) do
                if Survivor.ALLOWED_CARD_TYPES[entry.gm_notes] then
                    log:Debugf("Deleting %s/%s", entry.name, entry.gm_notes)
                    table.insert(toDelete, entry.name)
                end
            end
            container:Delete(toDelete)
        else
            table.insert(remainingObjects, object)
        end
    end

    for _, object in ipairs(Location.Get("Player "..self.ordinal.." Gear"):AllObjects()) do
        if object.tag == "Card" or object.tag == "Deck" then
            local container = Container(object)
            local toDelete = {}
            for _, entry in ipairs(container:Objects()) do
                if entry.gm_notes == "Gear" then
                    log:Debugf("checking %s/%s", entry.name, entry.gm_notes)
                    local gear = Gear.getByName(entry.name)
                    if gear and (gear.stats.cursed or (gear.stats.irreplaceable and survivor:Dead()))then
                        log:Broadcastf(gear.stats.cursed and "taking %s to settlement because it's cursed" or "archiving %s because it's irreplacaeble", entry.name)
                        table.insert(toDelete, entry.name)
                    end
                end
            end
            container:Delete(toDelete)
        end
    end

    if self:FigurineObject() then
        self:FigurineObject().destruct()
        self:UnlinkFigurine()
    end

    if self:PortraitObject() then
        self:PortraitObject().destruct()
        self:UnlinkPortrait()
    end

    if self:BingoObject() then
        self:BingoObject().destruct()
        self:UnlinkBingo()
    end

    if #remainingObjects > 0 then
        log:Errorf("Some cards or objects were not returned with the self to the settlement. Please record these manually.")
        Util.HighlightAll(remainingObjects)
    end

    survivorSheet:Object().destruct()

    EventManager.FireEvent(EventManager.ON_SURVIVOR_BACK_TO_SETTLEMENT, survivor)

    log:Printf("Returned %s to settlement", survivor:NameOrUnnamed())
end

---------------------------------------------------------------------------------------------------

function Player:LinkFigurine(figurineObject)
    self:UnlinkFigurine()

    for _, otherPlayer in ipairs(Player.players) do
        if otherPlayer.figurineObject == figurineObject then
            otherPlayer:UnlinkFigurine()
        end
    end

    log:Debugf("Linking figurine [%s] %s to %s", figurineObject.getGUID(), figurineObject.getName(), self)
    figurineObject.setColorTint(self.markerObject.getColorTint())
    if self.survivorSheet then
        local name = self.survivorSheet:Survivor():NameOrUnnamed()
        figurineObject.setName(name)
        self.survivorSheet:Survivor():SetFigurineJSON(figurineObject.getJSON())
        log:Printf("Linked figurine to player %s (%s)", self.ordinal, name)
    else
        log:Debugf("Linked figurine to player %s", self.ordinal)
    end

    self.figurineObject = figurineObject
end

---------------------------------------------------------------------------------------------------

function Player:UnlinkFigurine()
    local figurineObject = self.figurineObject
    if not figurineObject then
        return
    end

    log:Debugf("Unlinking figurine [%s] %s) from %s", figurineObject.getGUID(), figurineObject.getName(), self)
    figurineObject.setName("Unnamed Survivor")
    figurineObject.setColorTint({ r = 0, g = 0, b = 0 })
    self.figurineObject = nil
end

---------------------------------------------------------------------------------------------------

function Player:LinkPortrait(portraitObject)
    self:UnlinkPortrait()

    for _, otherPlayer in ipairs(Player.players) do
        if otherPlayer.portraitObject == portraitObject then
            otherPlayer:UnlinkPortrait()
        end
    end

    log:Debugf("Linking portrait [%s] %s to %s", portraitObject.getGUID(), portraitObject.getName(), self)
    --portraitObject.setColorTint(self.markerObject.getColorTint())
    if self.survivorSheet then
        local name = self.survivorSheet:Survivor():NameOrUnnamed()
        portraitObject.setName(name)
        self.survivorSheet:Survivor():SetPortraitJSON(portraitObject.getJSON())
        log:Printf("Linked portrait to player %s (%s)", self.ordinal, name)
    else
        log:Debugf("Linked portrait to player %s", self.ordinal)
    end

    self.portraitObject = portraitObject
end

---------------------------------------------------------------------------------------------------

function Player:UnlinkPortrait()
    local portraitObject = self.portraitObject
    if not portraitObject then
        return
    end

    log:Debugf("Unlinking portrait [%s] %s) from %s", portraitObject.getGUID(), portraitObject.getName(), self)
    portraitObject.setName("Unnamed Survivor")
    --portraitObject.setColorTint({ r = 0, g = 0, b = 0 })
    self.portraitObject = nil
end

---------------------------------------------------------------------------------------------------

function Player:LinkBingo(bingoObject)
    self:UnlinkBingo()

    for _, otherPlayer in ipairs(Player.players) do
        if otherPlayer.bingoObject == bingoObject then
            otherPlayer:UnlinkBingo()
        end
    end

    log:Debugf("Linking bingo [%s] %s to %s", bingoObject.getGUID(), bingoObject.getName(), self)
    bingoObject.editButton({
            index = 24,
            color = self.markerObject.getColorTint(),
    })
    bingoObject.call("onSave")
    if self.survivorSheet then
        local name = self.survivorSheet:Survivor():NameOrUnnamed()
        bingoObject.setName(name.."'s Bingo")
        self.survivorSheet:Survivor():SetBingoJSON(bingoObject.getJSON())
    else
        log:Debugf("Linked bingo to player %s", self.ordinal)
    end
    self.bingoObject = bingoObject
end

---------------------------------------------------------------------------------------------------

function Player:UnlinkBingo()
    local bingoObject = self.bingoObject
    if not bingoObject then
        return
    end

    log:Debugf("Unlinking bingo [%s] %s) from %s", bingoObject.getGUID(), bingoObject.getName(), self)
    bingoObject.setName("Unnamed Survivor's Bingo")
    bingoObject.editButton({
            index = 24,
            color = {0, 0, 0},
    })
    bingoObject.call("onSave")
    self.bingoObject = nil
end

---------------------------------------------------------------------------------------------------

function Player:FigurineObject()
    return self.figurineObject
end

---------------------------------------------------------------------------------------------------

function Player:PortraitObject()
    return self.portraitObject
end

---------------------------------------------------------------------------------------------------

function Player:BingoObject()
    return self.bingoObject
end

---------------------------------------------------------------------------------------------------

return {
    Is = Player.Is,
    Create = Player.Create,
    Init = Player.Init,
    PostInit = Player.PostInit,
    Save = Player.Save,
    Players = function() return Player.players end,
    ForFigurine = Player.ForFigurine,
    ForPortrait = Player.ForPortrait,
    ForBingo = Player.ForBingo,
}
