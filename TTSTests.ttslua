-- TTS Console Test Harness
-- These tests run inside TTS via console commands to verify actual behavior
-- Usage: Type ">testhelp" in TTS chat to see available tests

local Console = require("Kdm/Console")
local Location = require("Kdm/Location")
local Archive = require("Kdm/Archive")
local Strain = require("Kdm/Strain")
local FightingArtsArchive = require("Kdm/FightingArtsArchive")
local VerminArchive = require("Kdm/VerminArchive")
local log = require("Kdm/Log").ForModule("TTSTests")

---------------------------------------------------------------------------------------------------

local TTSTests = {}

---------------------------------------------------------------------------------------------------

function TTSTests.Init()
    Console.AddCommand("testhelp", function(args)
        log:Printf("Available TTS tests:")
        log:Printf("  >teststrain [cardname] - Test adding a strain fighting art to the deck")
        log:Printf("  >teststrainvermin [cardname] - Test adding a strain vermin card to the deck")
        log:Printf("  >testdialogspec - Test DialogFromSpec callback timing issue")
        log:Printf("  >testcardstate [stateId] - Test archive fallback for Story of Blood stateful names")
    end, "Show available TTS test commands")
    
    TTSTests.RegisterStrainTests()
    TTSTests.RegisterDialogFromSpecTests()
end

---------------------------------------------------------------------------------------------------
-- Strain Tests
---------------------------------------------------------------------------------------------------

function TTSTests.RegisterStrainTests()
    Console.AddCommand("teststrain", function(args)
        local cardName = args[2] or "Shielderang"
        TTSTests.TestAddFightingArtToArchive(cardName)
    end, "<cardname> - Test adding a strain fighting art to the deck")

    Console.AddCommand("teststrainvermin", function(args)
        local cardName = args[2] or "Fiddler Crab Spider"
        TTSTests.TestAddVerminToDeck(cardName)
    end, "<cardname> - Test adding a strain vermin card to the deck")

    Console.AddCommand("testcardstate", function(args)
        local stateId = tonumber(args[2])
        TTSTests.TestCardStateFallback("Story of Blood", stateId)
    end, "[stateId] - Test spawning Story of Blood after changing its state")
end

function TTSTests.TestAddFightingArtToArchive(cardName)
    log:Printf("=== TEST: TestAddFightingArtToArchive ===")
    TTSTests.RunDeckExperiment(cardName, function()
        log:Printf("TEST: AddFightingArtToArchive with card: %s", cardName)
        local result = FightingArtsArchive.AddCard(cardName)
        log:Printf("TEST: AddFightingArtToArchive returned: %s", tostring(result))
        return result
    end, {
        deckLabel = "Fighting Arts",
        stateFunc = TTSTests.GetFightingArtsDeckState,
        cleanup = TTSTests.RestoreFightingArtsDeck,
    })
end

function TTSTests.TestAddVerminToDeck(cardName)
    log:Printf("=== TEST: TestAddVerminToDeck ===")
    TTSTests.RunDeckExperiment(cardName, function()
        log:Printf("TEST: AddVerminToDeck with card: %s", cardName)
        local result = VerminArchive.AddCard(cardName)
        log:Printf("TEST: AddVerminToDeck returned: %s", tostring(result))
        return result
    end, {
        deckLabel = "Vermin",
        stateFunc = TTSTests.GetVerminDeckState,
        cleanup = TTSTests.RestoreVerminDeck,
    })
end

function TTSTests.TestCardStateFallback(baseName, stateId)
    log:Printf("=== TEST: TestCardStateFallback ===")
    baseName = baseName or "Story of Blood"
    
    local totalBefore, matchesBefore = TTSTests.GetStrainRewardsDeckState(baseName)
    log:Printf("TEST BEFORE: Strain Rewards deck has %d cards, %d copies of '%s'", totalBefore, matchesBefore, baseName)
    
    local locationName = "South of Showdown Board"
    local location = Location.Get(locationName)
    assert(location, string.format("TEST: Location '%s' not found", locationName))

    -- Test: Spawn card with alternate state name suffix like "Story of Blood [1, 1 x]"
    -- The fallback mechanism should strip the suffix and find the base card
    local stateName = stateId or "1, 1 x"  -- Default to an existing state for Story of Blood
    local testName = string.format("%s [%s]", baseName, stateName)
    log:Printf("TEST: Attempting to spawn '%s' from archive (testing state name fallback)", testName)
    
    local position = location:Center()
    position.y = position.y + 2
    local spawnedCard
    local ok = Strain._test._TakeRewardCard(Strain, {
        name = testName,
        type = FightingArtsArchive.FIGHTING_ART_TYPE,
        position = position,
        rotation = { x = 0, y = 180, z = 0 },
        spawnFunc = function(card)
            spawnedCard = card
        end,
    })
    
    if ok and spawnedCard then
        log:Printf("TEST: Successfully spawned '%s' via fallback mechanism", testName)
    else
        log:Errorf("TEST: Failed to spawn '%s' - fallback mechanism failed", testName)
    end

    Wait.frames(function()
        if spawnedCard and spawnedCard.destruct then
            spawnedCard.destruct()
        end
        Archive.Clean()
        
        Wait.frames(function()
            local totalAfter, matchesAfter = TTSTests.GetStrainRewardsDeckState(baseName)
            log:Printf("TEST AFTER: Strain Rewards deck has %d cards, %d copies of '%s'", totalAfter, matchesAfter, baseName)
            
            if totalAfter ~= totalBefore then
                log:Errorf("TEST CLEANUP WARNING: Strain Rewards deck changed from %d to %d cards. Manual verification recommended.", totalBefore, totalAfter)
            else
                log:Printf("TEST CLEANUP: Successfully restored Strain Rewards deck.")
            end
        end, 20)
    end, 10)
end

function TTSTests.RunDeckExperiment(cardName, mutateFn, options)
    local deckLabel = options.deckLabel or "Deck"
    local totalBefore, matchesBefore = options.stateFunc(cardName)
    log:Printf("TEST BEFORE: %s deck has %d cards, %d copies of '%s'", deckLabel, totalBefore, matchesBefore, cardName)

    local ok, err = pcall(mutateFn)
    if not ok then
        log:Errorf("TEST FAILED: error while executing action: %s", tostring(err))
        return
    end

    Wait.frames(function()
        local totalAfter, matchesAfter = options.stateFunc(cardName)
        log:Printf("TEST AFTER: %s deck has %d cards, %d copies of '%s'", deckLabel, totalAfter, matchesAfter, cardName)

        local delta = matchesAfter - matchesBefore
        if delta > 0 then
            log:Printf("TEST INFO: Detected %d new copies of '%s'. Scheduling cleanup.", delta, cardName)
            options.cleanup(cardName, delta, matchesBefore, options.stateFunc)
        elseif delta == 0 then
            log:Printf("TEST INFO: Copy count unchanged. No cleanup required.")
        else
            log:Errorf("TEST WARNING: Deck has fewer copies of '%s' (%d) than baseline (%d). Manual verification recommended.", cardName, matchesAfter, matchesBefore)
        end
    end, 30)
end

local function restoreDeck(cardName, copiesToRemove, targetCopies, removeFunc, deckLabel, stateFunc)
    local removed = 0

    local function finalizeCleanup()
        Wait.frames(function()
            local _, matches = stateFunc(cardName)
            if targetCopies and matches ~= targetCopies then
                log:Errorf("TEST CLEANUP: Expected %d copies of '%s' after cleanup but found %d.", targetCopies, cardName, matches)
            else
                log:Printf("TEST CLEANUP: Restored %s deck to %d copies of '%s'.", deckLabel, matches, cardName)
            end
        end, 20)
    end

    local function removeNext()
        if removed >= copiesToRemove then
            finalizeCleanup()
            return
        end

        local success = removeFunc(cardName)
        if not success then
            log:Errorf("TEST CLEANUP: Failed while removing '%s' (%d/%d). Deck may contain leftover copies.", cardName, removed + 1, copiesToRemove)
            return
        end

        removed = removed + 1
        Wait.frames(removeNext, 10)
    end

    removeNext()
end

function TTSTests.RestoreFightingArtsDeck(cardName, copiesToRemove, targetCopies, stateFunc)
    restoreDeck(cardName, copiesToRemove, targetCopies, FightingArtsArchive.RemoveCard, "Fighting Arts", stateFunc or TTSTests.GetFightingArtsDeckState)
end

function TTSTests.RestoreVerminDeck(cardName, copiesToRemove, targetCopies, stateFunc)
    restoreDeck(cardName, copiesToRemove, targetCopies, VerminArchive.RemoveCard, "Vermin", stateFunc or TTSTests.GetVerminDeckState)
end

function TTSTests.GetFightingArtsDeckState(cardName)
    local location = Location.Get("Fighting Arts")
    if not location then
        return 0, 0
    end
    local deck = location:FirstObject({ types = { "Fighting Arts" } })
    local count = 0
    local matchCount = 0
    
    if deck then
        local objects = deck.getObjects()
        count = #objects
        for _, obj in ipairs(objects) do
            if obj.name == cardName then
                matchCount = matchCount + 1
            end
        end
    end
    
    return count, matchCount
end

function TTSTests.GetVerminDeckState(cardName)
    local location = Location.Get("Vermin")
    if not location then
        return 0, 0
    end
    local deck = location:FirstObject({ types = { "Vermin" } })
    local count = 0
    local matchCount = 0

    if deck then
        local objects = deck.getObjects()
        count = #objects
        for _, obj in ipairs(objects) do
            if obj.name == cardName then
                matchCount = matchCount + 1
            end
        end
    end

    return count, matchCount
end

function TTSTests.GetStrainRewardsDeckState(cardName)
    local deckName = "Strain Rewards"
    log:Debugf("[DEBUG] GetStrainRewardsDeckState: calling Archive.Take")
    local deck = Archive.Take({
        name = deckName,
        type = "Rewards",
        position = { x = -150, y = 60, z = 120 },
        lenient = true,
    })
    log:Debugf("[DEBUG] GetStrainRewardsDeckState: Archive.Take returned deck=%s", tostring(deck))
    log:Debugf("[DEBUG] GetStrainRewardsDeckState: calling Archive.Clean")
    Archive.Clean()
    log:Debugf("[DEBUG] GetStrainRewardsDeckState: Archive.Clean done")
    
    if not deck then
        log:Debugf("[DEBUG] GetStrainRewardsDeckState: deck is nil, returning 0,0")
        return 0, 0
    end
    
    log:Debugf("[DEBUG] GetStrainRewardsDeckState: deck.getObjects type=%s", type(deck.getObjects))
    local count = 0
    local matchCount = 0
    local objects = deck.getObjects and deck.getObjects()
    log:Debugf("[DEBUG] GetStrainRewardsDeckState: objects=%s", tostring(objects))
    
    if objects then
        count = #objects
        for _, obj in ipairs(objects) do
            if obj.name == cardName then
                matchCount = matchCount + 1
            end
        end
    end
    log:Debugf("[DEBUG] GetStrainRewardsDeckState: count=%d, matchCount=%d", count, matchCount)
    
    log:Debugf("[DEBUG] GetStrainRewardsDeckState: calling deck.destruct")
    deck.destruct()
    log:Debugf("[DEBUG] GetStrainRewardsDeckState: deck.destruct done")
    
    -- Note: Core Archive is an infinite bag, no need to reset
    log:Debugf("[DEBUG] GetStrainRewardsDeckState: returning count=%d, matchCount=%d", count, matchCount)
    return count, matchCount
end

---------------------------------------------------------------------------------------------------
-- DialogFromSpec Callback Timing Tests
---------------------------------------------------------------------------------------------------

function TTSTests.RegisterDialogFromSpecTests()
    Console.AddCommand("testdialogspec", function(args)
        TTSTests.TestDialogFromSpecCallbackTiming()
    end, "Test DialogFromSpec callback timing issue")
end

function TTSTests.TestDialogFromSpecCallbackTiming()
    log:Printf("=== TEST: TestDialogFromSpecCallbackTiming ===")
    local PanelKit = require("Kdm/Ui/PanelKit")
    local LayoutManager = require("Kdm/Ui/LayoutManager")
    
    -- This simulates the Campaign bug:
    -- layoutSpec callbacks reference a variable that's set AFTER DialogFromSpec returns
    
    local lateInitializedVar = nil  -- Will be set after DialogFromSpec
    
    local layoutSpec = LayoutManager.Specification()
    layoutSpec:AddText({
        id = "TestLabel",
        text = "Test",
        fontSize = 16,
    })
    layoutSpec:AddCustom({
        height = 40,
        render = function(context)
            -- This callback runs INSIDE DialogFromSpec, before lateInitializedVar is set
            log:Printf("TEST: Inside render callback, lateInitializedVar = %s", tostring(lateInitializedVar))
            if lateInitializedVar == nil then
                log:Printf("TEST: BUG REPRODUCED - callback runs before variable is initialized")
                -- In the real bug, this would be: lateInitializedVar:SomeMethod() -> nil index error
            else
                log:Printf("TEST: Variable was initialized: %s", tostring(lateInitializedVar))
            end
            -- Return a dummy element
            return context.parent:Text({
                id = "TestDummy",
                x = context.x,
                y = context.y,
                width = context.width,
                height = context.height,
                text = "Dummy",
            })
        end,
    })
    
    log:Printf("TEST: Calling DialogFromSpec...")
    local ok, result = pcall(function()
        return PanelKit.DialogFromSpec({
            id = "TestDialog",
            width = 300,
            spec = layoutSpec,
            title = "Test Dialog",
            layout = {
                padding = 10,
                spacing = 10,
                chromeOverhead = 100,
            },
        })
    end)
    
    if not ok then
        log:Printf("TEST: DialogFromSpec threw error: %s", tostring(result))
    else
        log:Printf("TEST: DialogFromSpec returned successfully")
        result.dialog:Hide()
    end
    
    -- This is where the variable would be set in the real code
    lateInitializedVar = "NOW_INITIALIZED"
    log:Printf("TEST: lateInitializedVar now set to: %s", lateInitializedVar)
    
    log:Printf("TEST COMPLETE: The bug is that callbacks run BEFORE this line")
end

---------------------------------------------------------------------------------------------------

return {
    Init = TTSTests.Init,
}
