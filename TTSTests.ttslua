-- TTS Console Test Harness
-- These tests run inside TTS via console commands to verify actual behavior
-- Usage: Type ">testhelp" in TTS chat to see available tests

local Console = require("Kdm/Console")
local Location = require("Kdm/Location")
local FightingArtsArchive = require("Kdm/FightingArtsArchive")
local VerminArchive = require("Kdm/VerminArchive")
local log = require("Kdm/Log").ForModule("TTSTests")

---------------------------------------------------------------------------------------------------

local TTSTests = {}

---------------------------------------------------------------------------------------------------

function TTSTests.Init()
    Console.AddCommand("testhelp", function(args)
        log:Printf("Available TTS tests:")
        log:Printf("  >teststrain [cardname] - Test adding a strain fighting art to the deck")
        log:Printf("  >teststrainvermin [cardname] - Test adding a strain vermin card to the deck")
        log:Printf("  >testdialogspec - Test DialogFromSpec callback timing issue")
    end, "Show available TTS test commands")
    
    TTSTests.RegisterStrainTests()
    TTSTests.RegisterDialogFromSpecTests()
end

---------------------------------------------------------------------------------------------------
-- Strain Tests
---------------------------------------------------------------------------------------------------

function TTSTests.RegisterStrainTests()
    Console.AddCommand("teststrain", function(args)
        local cardName = args[2] or "Shielderang"
        TTSTests.TestAddFightingArtToArchive(cardName)
    end, "<cardname> - Test adding a strain fighting art to the deck")

    Console.AddCommand("teststrainvermin", function(args)
        local cardName = args[2] or "Fiddler Crab Spider"
        TTSTests.TestAddVerminToDeck(cardName)
    end, "<cardname> - Test adding a strain vermin card to the deck")
end

function TTSTests.TestAddFightingArtToArchive(cardName)
    TTSTests.RunDeckExperiment(cardName, function()
        log:Printf("TEST: AddFightingArtToArchive with card: %s", cardName)
        local result = FightingArtsArchive.AddCard(cardName)
        log:Printf("TEST: AddFightingArtToArchive returned: %s", tostring(result))
        return result
    end, {
        deckLabel = "Fighting Arts",
        stateFunc = TTSTests.GetFightingArtsDeckState,
        cleanup = TTSTests.RestoreFightingArtsDeck,
    })
end

function TTSTests.TestAddVerminToDeck(cardName)
    TTSTests.RunDeckExperiment(cardName, function()
        log:Printf("TEST: AddVerminToDeck with card: %s", cardName)
        local result = VerminArchive.AddCard(cardName)
        log:Printf("TEST: AddVerminToDeck returned: %s", tostring(result))
        return result
    end, {
        deckLabel = "Vermin",
        stateFunc = TTSTests.GetVerminDeckState,
        cleanup = TTSTests.RestoreVerminDeck,
    })
end

function TTSTests.RunDeckExperiment(cardName, mutateFn, options)
    local deckLabel = options.deckLabel or "Deck"
    local totalBefore, matchesBefore = options.stateFunc(cardName)
    log:Printf("TEST BEFORE: %s deck has %d cards, %d copies of '%s'", deckLabel, totalBefore, matchesBefore, cardName)

    local ok, err = pcall(mutateFn)
    if not ok then
        log:Errorf("TEST FAILED: error while executing action: %s", tostring(err))
        return
    end

    Wait.frames(function()
        local totalAfter, matchesAfter = options.stateFunc(cardName)
        log:Printf("TEST AFTER: %s deck has %d cards, %d copies of '%s'", deckLabel, totalAfter, matchesAfter, cardName)

        local delta = matchesAfter - matchesBefore
        if delta > 0 then
            log:Printf("TEST INFO: Detected %d new copies of '%s'. Scheduling cleanup.", delta, cardName)
            options.cleanup(cardName, delta, matchesBefore, options.stateFunc)
        elseif delta == 0 then
            log:Printf("TEST INFO: Copy count unchanged. No cleanup required.")
        else
            log:Errorf("TEST WARNING: Deck has fewer copies of '%s' (%d) than baseline (%d). Manual verification recommended.", cardName, matchesAfter, matchesBefore)
        end
    end, 30)
end

local function restoreDeck(cardName, copiesToRemove, targetCopies, removeFunc, deckLabel, stateFunc)
    local removed = 0

    local function finalizeCleanup()
        Wait.frames(function()
            local _, matches = stateFunc(cardName)
            if targetCopies and matches ~= targetCopies then
                log:Errorf("TEST CLEANUP: Expected %d copies of '%s' after cleanup but found %d.", targetCopies, cardName, matches)
            else
                log:Printf("TEST CLEANUP: Restored %s deck to %d copies of '%s'.", deckLabel, matches, cardName)
            end
        end, 20)
    end

    local function removeNext()
        if removed >= copiesToRemove then
            finalizeCleanup()
            return
        end

        local success = removeFunc(cardName)
        if not success then
            log:Errorf("TEST CLEANUP: Failed while removing '%s' (%d/%d). Deck may contain leftover copies.", cardName, removed + 1, copiesToRemove)
            return
        end

        removed = removed + 1
        Wait.frames(removeNext, 10)
    end

    removeNext()
end

function TTSTests.RestoreFightingArtsDeck(cardName, copiesToRemove, targetCopies, stateFunc)
    restoreDeck(cardName, copiesToRemove, targetCopies, FightingArtsArchive.RemoveCard, "Fighting Arts", stateFunc or TTSTests.GetFightingArtsDeckState)
end

function TTSTests.RestoreVerminDeck(cardName, copiesToRemove, targetCopies, stateFunc)
    restoreDeck(cardName, copiesToRemove, targetCopies, VerminArchive.RemoveCard, "Vermin", stateFunc or TTSTests.GetVerminDeckState)
end

function TTSTests.GetFightingArtsDeckState(cardName)
    local location = Location.Get("Fighting Arts")
    if not location then
        return 0, 0
    end
    local deck = location:FirstObject({ types = { "Fighting Arts" } })
    local count = 0
    local matchCount = 0
    
    if deck then
        local objects = deck.getObjects()
        count = #objects
        for _, obj in ipairs(objects) do
            if obj.name == cardName then
                matchCount = matchCount + 1
            end
        end
    end
    
    return count, matchCount
end

function TTSTests.GetVerminDeckState(cardName)
    local location = Location.Get("Vermin")
    if not location then
        return 0, 0
    end
    local deck = location:FirstObject({ types = { "Vermin" } })
    local count = 0
    local matchCount = 0

    if deck then
        local objects = deck.getObjects()
        count = #objects
        for _, obj in ipairs(objects) do
            if obj.name == cardName then
                matchCount = matchCount + 1
            end
        end
    end

    return count, matchCount
end

---------------------------------------------------------------------------------------------------
-- DialogFromSpec Callback Timing Tests
---------------------------------------------------------------------------------------------------

function TTSTests.RegisterDialogFromSpecTests()
    Console.AddCommand("testdialogspec", function(args)
        TTSTests.TestDialogFromSpecCallbackTiming()
    end, "Test DialogFromSpec callback timing issue")
end

function TTSTests.TestDialogFromSpecCallbackTiming()
    local PanelKit = require("Kdm/Ui/PanelKit")
    local LayoutManager = require("Kdm/Ui/LayoutManager")
    
    log:Printf("TEST: DialogFromSpec callback timing")
    
    -- This simulates the Campaign bug:
    -- layoutSpec callbacks reference a variable that's set AFTER DialogFromSpec returns
    
    local lateInitializedVar = nil  -- Will be set after DialogFromSpec
    
    local layoutSpec = LayoutManager.Specification()
    layoutSpec:AddText({
        id = "TestLabel",
        text = "Test",
        fontSize = 16,
    })
    layoutSpec:AddCustom({
        height = 40,
        render = function(context)
            -- This callback runs INSIDE DialogFromSpec, before lateInitializedVar is set
            log:Printf("TEST: Inside render callback, lateInitializedVar = %s", tostring(lateInitializedVar))
            if lateInitializedVar == nil then
                log:Printf("TEST: BUG REPRODUCED - callback runs before variable is initialized")
                -- In the real bug, this would be: lateInitializedVar:SomeMethod() -> nil index error
            else
                log:Printf("TEST: Variable was initialized: %s", tostring(lateInitializedVar))
            end
            -- Return a dummy element
            return context.parent:Text({
                id = "TestDummy",
                x = context.x,
                y = context.y,
                width = context.width,
                height = context.height,
                text = "Dummy",
            })
        end,
    })
    
    log:Printf("TEST: Calling DialogFromSpec...")
    local ok, result = pcall(function()
        return PanelKit.DialogFromSpec({
            id = "TestDialog",
            width = 300,
            spec = layoutSpec,
            title = "Test Dialog",
            layout = {
                padding = 10,
                spacing = 10,
                chromeOverhead = 100,
            },
        })
    end)
    
    if not ok then
        log:Printf("TEST: DialogFromSpec threw error: %s", tostring(result))
    else
        log:Printf("TEST: DialogFromSpec returned successfully")
        result.dialog:Hide()
    end
    
    -- This is where the variable would be set in the real code
    lateInitializedVar = "NOW_INITIALIZED"
    log:Printf("TEST: lateInitializedVar now set to: %s", lateInitializedVar)
    
    log:Printf("TEST COMPLETE: The bug is that callbacks run BEFORE this line")
end

---------------------------------------------------------------------------------------------------

return {
    Init = TTSTests.Init,
}
