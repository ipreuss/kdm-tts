local Check = require("Kdm/Util/Check")
local Ui = require("Kdm/Ui")

---------------------------------------------------------------------------------------------------

local LayoutManager = {}

---------------------------------------------------------------------------------------------------
-- Constants
---------------------------------------------------------------------------------------------------

LayoutManager.FONT_HEIGHT_MULTIPLIER = 1.5
LayoutManager.CONTENT_HEIGHT_MULTIPLIER = 6.25
LayoutManager.DEFAULT_CHROME_OVERHEAD = 195

LayoutManager.Elements = {}

local Elements = LayoutManager.Elements

local Specification = {}
Specification.__index = Specification

local function shallowCopy(source)
    if not source then
        return {}
    end
    local copy = {}
    for k, v in pairs(source) do
        copy[k] = v
    end
    return copy
end

local function ensureTable(value)
    if type(value) == "table" then
        return value
    end
    if value == nil then
        return {}
    end
    return { height = value }
end

local function newElementState(state, metatable)
    state = state or {}
    state._isLayoutElement = true
    return setmetatable(state, metatable)
end

local TextElement = {}
TextElement.__index = TextElement

function TextElement:new(config)
    return newElementState({
        params = config.params or {},
        defaults = config.defaults or {},
        heightMultiplier = config.heightMultiplier or LayoutManager.FONT_HEIGHT_MULTIPLIER,
    }, TextElement)
end

function TextElement:_fontSize()
    return self.params.fontSize or self.defaults.fontSize or 14
end

function TextElement:_resolveId(layout)
    if self.params.id then
        return self.params.id
    end
    if self.defaults.id then
        return self.defaults.id
    end
    local prefix = self.defaults.idPrefix or "LayoutText"
    return layout:_nextElementId(prefix)
end

function TextElement:_x(layout)
    if self.params.x ~= nil then
        return self.params.x
    end
    if self.params.indent then
        return layout:_getContentX() + self.params.indent
    end
    return layout:_getContentX()
end

function TextElement:_width(layout)
    if self.params.width ~= nil then
        return self.params.width
    end
    if self.params.indent then
        return layout:_getContentWidth() - self.params.indent
    end
    return layout:_getContentWidth()
end

function TextElement:MeasureHeight()
    if self.params.height then
        return self.params.height
    end
    return self:_fontSize() * self.heightMultiplier
end

function TextElement:Render(layout)
    local height = self:MeasureHeight()
    local y = layout:_getNextY(height)
    local element = layout.parent:Text({
        id = self:_resolveId(layout),
        x = self:_x(layout),
        y = y,
        width = self:_width(layout),
        height = height,
        text = self.params.text or "",
        fontSize = self:_fontSize(),
        fontStyle = self.params.fontStyle or self.defaults.fontStyle,
        color = self.params.color or self.defaults.color or Ui.DARK_BROWN,
        alignment = self.params.alignment or self.defaults.alignment or "UpperLeft",
        horizontalOverflow = self.params.horizontalOverflow or "Wrap",
        verticalOverflow = self.params.verticalOverflow or "Truncate",
    })
    self.rendered = element
    return element
end

local SpacerElement = {}
SpacerElement.__index = SpacerElement

function SpacerElement:new(params)
    return newElementState({ params = params or {} }, SpacerElement)
end

function SpacerElement:MeasureHeight(spacing)
    return self.params.height or spacing or 0
end

function SpacerElement:Render(layout)
    local height = self:MeasureHeight(layout.spacing)
    layout:_getNextY(height)
    return nil
end

local ButtonRowElement = {}
ButtonRowElement.__index = ButtonRowElement
ButtonRowElement.DEFAULT_HEIGHT = 45
ButtonRowElement.DEFAULT_SPACING = 20

function ButtonRowElement:new(params)
    return newElementState({ params = params or {} }, ButtonRowElement)
end

function ButtonRowElement:MeasureHeight()
    return self.params.height or ButtonRowElement.DEFAULT_HEIGHT
end

function ButtonRowElement:Render(layout)
    local buttons = self.params.buttons or {}
    local buttonHeight = self:MeasureHeight()
    local buttonSpacing = self.params.spacing or ButtonRowElement.DEFAULT_SPACING
    local y = layout:_getNextY(buttonHeight)

    local totalButtonWidth = 0
    for _, btn in ipairs(buttons) do
        totalButtonWidth = totalButtonWidth + (btn.width or 140)
    end
    local totalSpacing = (#buttons - 1) * buttonSpacing
    local totalWidth = totalButtonWidth + totalSpacing
    local startX = layout:_getContentX() + (layout:_getContentWidth() - totalWidth) / 2
    local currentX = startX

    local buttonElements = {}
    for i, btn in ipairs(buttons) do
        local width = btn.width or 140
        local element = layout.parent:Button({
            id = btn.id or ("LayoutButton" .. i),
            x = currentX,
            y = y,
            width = width,
            height = buttonHeight,
            text = btn.text,
            fontSize = btn.fontSize or 16,
            colors = btn.colors or Ui.MID_BROWN_COLORS,
            onClick = btn.onClick,
        })
        table.insert(buttonElements, element)
        currentX = currentX + width + buttonSpacing
    end

    self.rendered = buttonElements
    return buttonElements
end

local CompositeElement = {}
CompositeElement.__index = CompositeElement

function CompositeElement:new(children)
    return setmetatable({
        elements = children or {},
        _isCompositeElement = true,
    }, CompositeElement)
end

local function createTextElement(params, overrides, multiplier)
    overrides = overrides or {}
    local defaults = {
        fontSize = overrides.fontSize or 14,
        fontStyle = overrides.fontStyle,
        color = overrides.color or Ui.DARK_BROWN,
        alignment = overrides.alignment or "UpperLeft",
        id = overrides.id,
        idPrefix = overrides.idPrefix or "LayoutText",
    }
    return TextElement:new({
        params = params or {},
        defaults = defaults,
        heightMultiplier = multiplier or LayoutManager.FONT_HEIGHT_MULTIPLIER,
    })
end

function Elements.Text(params)
    return createTextElement(params, {})
end

function Elements.Title(params)
    return createTextElement(params, {
        fontSize = 24,
        fontStyle = "Bold",
        alignment = "UpperCenter",
        color = Ui.DARK_BROWN,
        id = "LayoutTitle",
    })
end

function Elements.Label(params)
    return createTextElement(params, {
        fontSize = 18,
        fontStyle = "Bold",
        color = Ui.DARK_BROWN,
    })
end

function Elements.Content(params)
    return createTextElement(params, {
        fontSize = 16,
        color = Ui.MID_BROWN,
    }, LayoutManager.CONTENT_HEIGHT_MULTIPLIER)
end

function Elements.Spacer(params)
    return SpacerElement:new(params or {})
end

function Elements.ButtonRow(params)
    return ButtonRowElement:new(params or {})
end

function Elements.Section(params)
    params = params or {}
    local labelElement = Elements.Label({
        id = params.labelId,
        text = params.label,
        fontSize = params.labelFontSize or 16,
        fontStyle = params.labelFontStyle or "Bold",
        color = params.labelColor,
        height = params.labelHeight,
    })
    local contentElement = Elements.Content({
        id = params.contentId,
        text = params.content,
        fontStyle = params.contentStyle,
        height = params.contentHeight,
        indent = params.indent or 10,
        fontSize = params.contentFontSize,
        color = params.contentColor,
    })
    return CompositeElement:new({ labelElement, contentElement })
end

local function normalizeElements(elements)
    local normalized = {}

    local function append(entry)
        if not entry then
            return
        end
        if entry._isLayoutElement then
            table.insert(normalized, entry)
        elseif entry._isCompositeElement then
            for _, child in ipairs(entry.elements or {}) do
                append(child)
            end
        elseif type(entry) == "table" then
            for _, child in ipairs(entry) do
                append(child)
            end
        end
    end

    append(elements or {})
    return normalized
end

local function newSpecification()
    local spec = {
        entries = {},
    }
    return setmetatable(spec, Specification)
end

function LayoutManager.Specification()
    return newSpecification()
end

function Specification:_addEntry(descriptorFactory, renderFn, onRender)
    assert(type(descriptorFactory) == "function", "descriptorFactory must be a function")
    assert(type(renderFn) == "function", "renderFn must be a function")
    table.insert(self.entries, {
        descriptorFactory = descriptorFactory,
        render = function(layout)
            local result = renderFn(layout)
            if onRender then
                onRender(result)
            end
            return result
        end,
    })
    return self
end

function Specification:AddElement(descriptorFactory, renderFn, onRender)
    return self:_addEntry(descriptorFactory, renderFn, onRender)
end

function Specification:AddTitle(params, onRender)
    local config = shallowCopy(params or {})
    return self:_addEntry(
        function()
            return Elements.Title(config)
        end,
        function(layout)
            return layout:AddTitle(config)
        end,
        onRender
    )
end

function Specification:AddLabel(params, onRender)
    local config = shallowCopy(params or {})
    return self:_addEntry(
        function()
            return Elements.Label(config)
        end,
        function(layout)
            return layout:AddLabel(config)
        end,
        onRender
    )
end

function Specification:AddContent(params, onRender)
    local config = shallowCopy(params or {})
    return self:_addEntry(
        function()
            return Elements.Content(config)
        end,
        function(layout)
            return layout:AddContent(config)
        end,
        onRender
    )
end

function Specification:AddText(params, onRender)
    local config = shallowCopy(params or {})
    return self:_addEntry(
        function()
            return Elements.Text(config)
        end,
        function(layout)
            return layout:AddText(config)
        end,
        onRender
    )
end

function Specification:AddSection(params, onRender)
    local config = shallowCopy(params or {})
    return self:_addEntry(
        function()
            return Elements.Section(config)
        end,
        function(layout)
            return layout:AddSection(config)
        end,
        onRender
    )
end

function Specification:AddSpacer(params)
    local config = shallowCopy(ensureTable(params))
    return self:_addEntry(
        function()
            return Elements.Spacer(config)
        end,
        function(layout)
            layout:AddSpacer(config.height)
        end
    )
end

function Specification:AddButtonRow(params, onRender)
    local config = shallowCopy(params or {})
    return self:_addEntry(
        function()
            return Elements.ButtonRow(config)
        end,
        function(layout)
            return layout:AddButtonRow(config)
        end,
        onRender
    )
end

function Specification:BuildElements()
    local elements = {}
    for _, entry in ipairs(self.entries) do
        local descriptor = entry.descriptorFactory()
        if descriptor then
            table.insert(elements, descriptor)
        end
    end
    return elements
end

function Specification:CalculateHeight(params)
    params = params or {}
    local calcParams = {}
    for k, v in pairs(params) do
        calcParams[k] = v
    end
    calcParams.elements = self:BuildElements()
    return LayoutManager.CalculateLayoutHeight(calcParams)
end

function Specification:CalculateDialogHeight(params)
    params = params or {}
    if params.chromeOverhead == nil then
        params.chromeOverhead = LayoutManager.DEFAULT_CHROME_OVERHEAD
    end
    return self:CalculateHeight(params)
end

function Specification:Render(layout)
    local results = {}
    for index, entry in ipairs(self.entries) do
        results[index] = entry.render(layout)
    end
    return results
end

---------------------------------------------------------------------------------------------------
-- Vertical Layout Manager
---------------------------------------------------------------------------------------------------

function LayoutManager.VerticalLayout(params)
    assert(Check.Table(params.parent), "VerticalLayout requires parent panel")
    
    local layout = {
        parent = params.parent,
        contentArea = params.contentArea or { contentX = 0, contentY = 0, contentWidth = params.width or 400, contentHeight = params.height or 300 },
        padding = params.padding or 10,
        spacing = params.spacing or 10,
        currentY = nil, -- Will be set to contentArea.contentY on first element
        elements = {},
        elementCounter = 0,
    }

    function layout:_getNextY(elementHeight)
        if self.currentY == nil then
            -- First element starts at top of content area
            self.currentY = self.contentArea.contentY - self.padding
        else
            -- Subsequent elements are spaced below previous
            self.currentY = self.currentY - self.spacing
        end
        -- Move down by element height for next element
        local elementY = self.currentY
        self.currentY = self.currentY - elementHeight
        

        
        return elementY
    end

    function layout:_getContentX()
        return self.contentArea.contentX + self.padding
    end

    function layout:_getContentWidth()
        return self.contentArea.contentWidth - (self.padding * 2)
    end

    function layout:_nextElementId(prefix)
        self.elementCounter = self.elementCounter + 1
        return string.format("%s%d", prefix or "LayoutElement", self.elementCounter)
    end

    function layout:_renderElement(element)
        if not element then
            return nil
        end
        local rendered = element:Render(self)
        table.insert(self.elements, element)
        return rendered
    end

    function layout:AddText(params)
        return self:_renderElement(Elements.Text(params))
    end

    function layout:AddTitle(params)
        return self:_renderElement(Elements.Title(params))
    end

    function layout:AddLabel(params)
        return self:_renderElement(Elements.Label(params))
    end

    function layout:AddContent(params)
        return self:_renderElement(Elements.Content(params))
    end

    function layout:AddSection(params)
        local label = self:_renderElement(Elements.Label({
            id = params.labelId,
            text = params.label,
            fontSize = params.labelFontSize or 16,
            fontStyle = params.labelFontStyle or "Bold",
            color = params.labelColor,
            height = params.labelHeight,
        }))
        
        local content = self:_renderElement(Elements.Content({
            id = params.contentId,
            text = params.content,
            fontStyle = params.contentStyle,
            height = params.contentHeight,
            indent = params.indent or 10,
            fontSize = params.contentFontSize,
            color = params.contentColor,
        }))
        
        return { label = label, content = content }
    end

    function layout:AddSpacer(height)
        self:_renderElement(Elements.Spacer({ height = height }))
    end

    function layout:AddButtonRow(params)
        return self:_renderElement(Elements.ButtonRow(params or {}))
    end

    function layout:GetUsedHeight()
        if self.currentY == nil then
            return 0
        end
        return self.contentArea.contentY - self.currentY + self.padding
    end

    function layout:AutoSize(params)
        params = params or {}
        local usedHeight = self:GetUsedHeight()
        local minHeight = params.minHeight or 200
        local maxHeight = params.maxHeight or 800
        local padding = params.padding or 40 -- Extra space for dialog chrome
        
        local requiredHeight = math.max(minHeight, math.min(maxHeight, usedHeight + padding))
        
        -- Update dialog size if a dialog was provided
        if params.dialog then
            params.dialog:SetHeight(requiredHeight)
            
            -- Also update the chrome if it was passed
            if params.chrome then
                -- Update chrome height to match dialog
                -- Chrome content area might need adjustment too
            end
        end
        
        return requiredHeight
    end

    return layout
end

-- Dry-run calculation method - calculates height without creating UI elements
function LayoutManager.CalculateLayoutHeight(params)
    params = params or {}
    local padding = params.padding or 10
    local spacing = params.spacing or 10
    local chromeOverhead = params.chromeOverhead or 40

    local elements = normalizeElements(params.elements or {})
    local totalHeight = padding * 2 -- Top and bottom padding

    for index, element in ipairs(elements) do
        totalHeight = totalHeight + (element:MeasureHeight(spacing) or 0)
        if index < #elements then
            totalHeight = totalHeight + spacing
        end
    end

    return totalHeight + chromeOverhead
end

function LayoutManager.CalculateDialogHeight(params)
    params = params or {}
    if params.chromeOverhead == nil then
        params.chromeOverhead = LayoutManager.DEFAULT_CHROME_OVERHEAD
    end
    return LayoutManager.CalculateLayoutHeight(params)
end

---------------------------------------------------------------------------------------------------

return LayoutManager
