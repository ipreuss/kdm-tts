local Check = require("Kdm/Util/Check")
local Ui = require("Kdm/Ui")
local LayoutManager = require("Kdm/Ui/LayoutManager")
local log = require("Kdm/Log").ForModule("PanelKit")

---------------------------------------------------------------------------------------------------

local PanelKit = {}

---------------------------------------------------------------------------------------------------
-- Dialog helpers ------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------

function PanelKit.Dialog(params)
    assert(Check.Str(params.id))
    assert(Check.Num(params.width))
    assert(Check.Num(params.height))

    local ui = params.ui or Ui.Get2d()
    local modalBlocker
    if params.modal then
        modalBlocker = ui:Panel({
            id = params.id.."ModalBlocker",
            rectAlignment = "MiddleCenter",
            x = 0,
            y = 0,
            z = params.modalZ or -9,
            width = params.modalWidth or 4000,
            height = params.modalHeight or 4000,
            color = params.modalColor or "#00000088",
            active = false,
        })
        modalBlocker.attributes.raycastTarget = true
    end
    local panel = ui:Panel({
        id = params.id,
        rectAlignment = params.rectAlignment or "MiddleCenter",
        x = params.x or 0,
        y = params.y or 0,
        width = params.width,
        height = params.height,
        active = params.active or false,
        color = params.color,
    })

    if params.image then
        panel:Image({
            id = params.id,
            image = params.image,
            x = 0,
            y = 0,
            width = params.width,
            height = params.height,
        })
    end

    local dialog = {
        id = params.id,
        panel = panel,
        uiOpen = params.active or false,
        perPlayer = params.perPlayer ~= false,
        onShow = params.onShow,
        onHide = params.onHide,
        modalBlocker = modalBlocker,
    }

    if params.closeButton ~= false then
        local close = params.closeButton or {}
        panel:Button({
            id = close.id or "Close",
            x = close.x or (params.width / 2 - 20),
            y = close.y or (params.height / 2 - 20),
            width = close.width or 30,
            height = close.height or 30,
            onClick = close.onClick or function(mouseButton, player)
                if dialog.perPlayer then
                    dialog:HideForPlayer(player)
                else
                    dialog:HideForAll()
                end
            end
        })
    end

    function dialog:Panel()
        return self.panel
    end

    function dialog:SetHeight(height)
        self.panel:SetAttribute("height", "number", height)
    end

    function dialog:ShowForPlayer(playerOrColor)
        if not self.perPlayer then
            self:ShowForAll()
            return "All"
        end

        local color = type(playerOrColor) == "string" and playerOrColor or playerOrColor.color
        local result = self.panel:ShowForPlayer(color)
        if result == color then
            self.uiOpen = true
            if self.modalBlocker then
                self.modalBlocker:ShowForPlayer(color)
            end
            if self.onShow then
                self.onShow(playerOrColor)
            end
        end
        return result
    end

    function dialog:HideForPlayer(playerOrColor)
        if not self.perPlayer then
            self:HideForAll()
            return "All"
        end

        local color = type(playerOrColor) == "string" and playerOrColor or playerOrColor.color
        local result = self.panel:HideForPlayer(color)
        if result == "None" or result == color then
            self.uiOpen = false
            if self.modalBlocker then
                self.modalBlocker:HideForPlayer(color)
            end
            if self.onHide then
                self.onHide(playerOrColor)
            end
        end
        return result
    end

    function dialog:ShowForAll()
        if self.modalBlocker then
            self.modalBlocker:Show()
        end
        self.panel:Show()
        self.uiOpen = true
        if self.onShow then
            self.onShow()
        end
    end

    function dialog:HideForAll()
        if self.modalBlocker then
            self.modalBlocker:Hide()
        end
        self.panel:Hide()
        self.uiOpen = false
        if self.onHide then
            self.onHide()
        end
    end

    function dialog:IsOpen()
        return self.uiOpen
    end

    return dialog
end

function PanelKit.ClassicDialog(params)
    assert(Check.Table(params.panel))

    local panel = params.panel
    local width = params.width or panel.attributes.width
    local height = params.height or panel.attributes.height
    local idPrefix = params.id or (panel.attributes.id .. "Classic")
    local inset = params.inset or 20
    local headerHeight = params.headerHeight or 110
    local contentPadding = params.contentPadding or 20
    local footerPadding = params.footerPadding or 20

    local innerWidth = width - inset * 2
    local innerHeight = height - inset * 2

    local shadow = panel:Panel({
        id = idPrefix.."Shadow",
        x = inset / 2,
        y = -(inset / 2),
        width = width,
        height = height,
        color = "#00000055",
        active = true,
    })
    local frame = panel:Panel({
        id = idPrefix.."Frame",
        x = 0,
        y = 0,
        width = width,
        height = height,
        color = Ui.DARK_BROWN,
        active = true,
    })
    local background = panel:Panel({
        id = idPrefix.."Background",
        x = inset,
        y = -inset,
        width = innerWidth,
        height = innerHeight,
        color = "#d8cab1f0",
        active = true,
    })

    local header = panel:Panel({
        id = idPrefix.."Header",
        x = inset,
        y = -inset,
        width = innerWidth,
        height = headerHeight,
        color = "#b1916cff",
        active = true,
    })
    local headerDivider = panel:Panel({
        id = idPrefix.."HeaderDivider",
        x = inset,
        y = -(inset + headerHeight),
        width = innerWidth,
        height = 4,
        color = Ui.DARK_BROWN,
        active = true,
    })

    local titleText
    if params.title then
        titleText = header:Text({
            id = idPrefix.."Title",
            x = contentPadding,
            y = -20,
            width = innerWidth - contentPadding * 2,
            height = 40,
            alignment = "MiddleLeft",
            fontSize = params.titleFontSize or 28,
            fontStyle = "Bold",
            color = Ui.DARK_BROWN,
            text = params.title,
        })
    end
    local subtitleText
    if params.subtitle then
        subtitleText = header:Text({
            id = idPrefix.."Subtitle",
            x = contentPadding,
            y = -58,
            width = innerWidth - contentPadding * 2,
            height = 30,
            alignment = "MiddleLeft",
            fontSize = params.subtitleFontSize or 16,
            color = Ui.MID_BROWN,
            text = params.subtitle,
        })
    end

    if params.closeButton ~= false then
        local close = params.closeButton or {}
        local onClose = close.onClick or params.onClose
        panel:Button({
            id = close.id or (idPrefix.."Close"),
            x = (width - inset) - (close.width or 30),
            y = -inset - ((close.height or 30) / 2),
            width = close.width or 30,
            height = close.height or 30,
            text = close.text or "X",
            fontSize = close.fontSize or 18,
            colors = close.colors or Ui.DARK_BROWN_COLORS,
            textColor = close.textColor or Ui.LIGHT_BROWN,
            onClick = onClose,
        })
    end

    local contentX = inset + contentPadding
    local contentY = -(inset + headerHeight + contentPadding)
    local contentWidth = innerWidth - contentPadding * 2
    local contentHeight = innerHeight - headerHeight - contentPadding - footerPadding

    local chrome = {
        contentX = contentX,
        contentY = contentY,
        contentWidth = contentWidth,
        contentHeight = contentHeight,
        inset = inset,
        headerHeight = headerHeight,
        contentPadding = contentPadding,
        footerPadding = footerPadding,
        width = width,
        height = height,
        elements = {
            shadow = shadow,
            frame = frame,
            background = background,
            header = header,
            headerDivider = headerDivider,
            titleText = titleText,
            subtitleText = subtitleText,
        },
    }

    function chrome:SetHeight(newHeight)
        self.height = newHeight
        local innerHeight = newHeight - self.inset * 2
        local newContentHeight = innerHeight - self.headerHeight - self.contentPadding - self.footerPadding
        self.contentHeight = newContentHeight
        self.elements.shadow:SetHeight(newHeight)
        self.elements.frame:SetHeight(newHeight)
        self.elements.background:SetHeight(innerHeight)
    end

    return chrome
end

function PanelKit.DialogFromSpec(params)
    log:Debugf("DialogFromSpec START")
    Check.Table(params)
    assert(params.spec and params.spec.Render, "spec is required")
    Check.Num(params.width)
    Check.Str(params.id)
    log:Debugf("DialogFromSpec: params validated, id=%s", tostring(params.id))

    local spec = params.spec
    local layoutOptions = params.layout or {}
    local padding = layoutOptions.padding or params.padding or 12
    local spacing = layoutOptions.spacing or params.spacing or 10
    local chromeOverhead = layoutOptions.chromeOverhead
    local minHeight = layoutOptions.minHeight or params.minHeight or 0
    log:Debugf("DialogFromSpec: layout options parsed")

    local contentHeight = spec:CalculateHeight({
        padding = padding,
        spacing = spacing,
        chromeOverhead = 0,
    })
    log:Debugf("DialogFromSpec: contentHeight=%d", contentHeight)
    local height = spec:CalculateDialogHeight({
        padding = padding,
        spacing = spacing,
        chromeOverhead = chromeOverhead,
    })
    log:Debugf("DialogFromSpec: height=%d", height)
    if minHeight and minHeight > 0 then
        height = math.max(minHeight, height)
    end
    log:Debugf("DialogFromSpec: final height=%d", height)

    local dialogOptions = {}
    for k, v in pairs(params.dialog or {}) do
        dialogOptions[k] = v
    end
    dialogOptions.id = params.id
    dialogOptions.ui = dialogOptions.ui or Ui.Get2d()
    dialogOptions.rectAlignment = dialogOptions.rectAlignment or "MiddleCenter"
    dialogOptions.width = params.width
    dialogOptions.height = height
    dialogOptions.color = dialogOptions.color or "#00000000"
    if dialogOptions.closeButton == nil then
        dialogOptions.closeButton = false
    end
    log:Debugf("DialogFromSpec: calling PanelKit.Dialog")

    local dialog = PanelKit.Dialog(dialogOptions)
    log:Debugf("DialogFromSpec: dialog created")
    local panel = dialog:Panel()
    log:Debugf("DialogFromSpec: panel created")

    local chromeOptions = {}
    for k, v in pairs(params.chrome or {}) do
        chromeOptions[k] = v
    end
    chromeOptions.panel = panel
    chromeOptions.id = chromeOptions.id or params.chromeId or params.id
    chromeOptions.width = params.width
    chromeOptions.height = height
    chromeOptions.title = chromeOptions.title or params.title
    chromeOptions.subtitle = chromeOptions.subtitle or params.subtitle
    if chromeOptions.closeButton == nil then
        chromeOptions.closeButton = false
    end
    log:Debugf("DialogFromSpec: calling ClassicDialog")

    local chrome = PanelKit.ClassicDialog(chromeOptions)
    log:Debugf("DialogFromSpec: chrome created")
    local layout = LayoutManager.VerticalLayout({
        parent = panel,
        contentArea = chrome,
        padding = padding,
        spacing = spacing,
    })
    log:Debugf("DialogFromSpec: layout created")
    spec:Render(layout)
    log:Debugf("DialogFromSpec: spec rendered")

    log:Debugf("DialogFromSpec END - returning result")
    return {
        dialog = dialog,
        panel = panel,
        chrome = chrome,
        layout = layout,
        height = height,
        contentHeight = contentHeight,
    }
end

---------------------------------------------------------------------------------------------------
-- Option list helpers --------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------

local function createScrollContainer(params)
    local containerId = params.containerId
    if not containerId then
        local suffix = (params.scroll == false) and "Container" or "Scroll"
        containerId = params.id .. suffix
    end

    local containerParams = {
        id = containerId,
        rectAlignment = params.rectAlignment,
        x = params.x or 0,
        y = params.y or 0,
        width = params.width,
        height = params.height,
        color = params.color,
        active = params.active,
    }

    if params.scroll == false then
        return params.parent:Panel(containerParams)
    end

    return params.parent:VerticalScroll(containerParams)
end

function PanelKit.ScrollArea(params)
    assert(Check.Table(params.parent))
    assert(Check.Str(params.id))
    assert(Check.Num(params.width))
    assert(Check.Num(params.height))

    local container = createScrollContainer(params)
    local panel = container:Panel({
        id = params.panelId or (params.id .. "Panel"),
        x = params.contentX or 0,
        y = params.contentY or 0,
        width = params.contentWidth or params.width,
        height = params.contentHeight or 0,
        color = params.contentColor,
        active = params.contentActive,
    })

    local area = {
        container = container,
        panel = panel,
    }

    function area:Panel()
        return self.panel
    end

    function area:ScrollView()
        return self.container
    end

    function area:SetContentHeight(height)
        self.panel:SetHeight(height)
    end

    return area
end

function PanelKit.OptionList(params)
    assert(Check.Table(params.parent))
    assert(Check.Str(params.id))
    assert(Check.Num(params.width))
    assert(Check.Num(params.height))

    local itemHeight = params.itemHeight or 30
    local contentWidth = params.contentWidth or params.width
    local scrollArea = PanelKit.ScrollArea({
        parent = params.parent,
        id = params.id,
        x = params.x,
        y = params.y,
        width = params.width,
        height = params.height,
        color = params.color,
        scroll = params.scroll,
        containerId = params.containerId,
        panelId = params.panelId,
        contentWidth = contentWidth,
        contentHeight = 0,
    })
    local panel = scrollArea:Panel()

    local group = panel:OptionButtonGroup({
        id = params.id,
        textAlignment = params.textAlignment or "MiddleCenter",
        fontSize = params.fontSize or 14,
        onClick = function(option)
            if params.onClick then
                params.onClick(option)
            end
        end,
        selectedColors = params.selectedColors,
        unselectedColors = params.unselectedColors,
        textColor = params.textColor,
    })

    local list = {
        itemHeight = itemHeight,
        panel = panel,
        scrollArea = scrollArea,
        group = group,
        buttons = {},
        width = params.itemWidth or contentWidth,
    }

    function list:SetOptions(options)
        local y = 0
        for i, option in ipairs(options) do
            local button = self.buttons[i]
            if not button then
                button = self.group:OptionButton({
                    x = 0,
                    y = y,
                    width = self.width,
                    height = self.itemHeight,
                    text = option.text or "",
                    optionValue = option.value,
                    selected = option.selected,
                    active = option.active ~= false,
                })
                self.buttons[i] = button
            else
                button:SetText(option.text or "")
                button:SetOptionValue(option.value)
                if option.active == false then
                    button:SetAttribute("active", "boolean", false)
                else
                    button:SetAttribute("active", "boolean", true)
                    button:Show()
                end
            end

            if option.selected then
                button:Select()
            end

            y = y - self.itemHeight
        end

        for j = #options + 1, #self.buttons do
            self.buttons[j]:Hide()
        end

        self.panel:SetHeight(#options * self.itemHeight)
    end

    function list:Clear()
        self.panel:SetHeight(0)
        for _, button in ipairs(self.buttons) do
            button:Hide()
        end
    end

    return list
end

---------------------------------------------------------------------------------------------------

-- Scroll selector (OptionList + helpers) ---------------------------------------------------------
---------------------------------------------------------------------------------------------------

function PanelKit.ScrollSelector(params)
    assert(Check.Table(params.parent))
    assert(Check.Str(params.id))
    assert(Check.Num(params.width))
    assert(Check.Num(params.height))

    local selectedValue = nil

    if params.label then
        params.parent:Text({
            id = params.id .. "Label",
            x = params.x,
            y = params.y + 12, -- slight offset for label
            width = params.width,
            height = 20,
            fontSize = params.label.fontSize or 14,
            color = params.label.color or Ui.LIGHT_BROWN,
            text = params.label.text or "",
            alignment = params.label.alignment or "MiddleCenter",
        })
        params.y = params.y - 20
    end

    local selector = PanelKit.OptionList({
        parent = params.parent,
        id = params.id,
        x = params.x,
        y = params.y,
        width = params.width,
        height = params.height,
        contentWidth = params.contentWidth,
        itemHeight = params.itemHeight,
        fontSize = params.fontSize,
        textAlignment = params.textAlignment,
        onClick = function(option)
            if option then
                if option.Select then
                    option:Select()
                end
                selectedValue = option:OptionValue()
            end
            if params.onSelect then
                params.onSelect(option:OptionValue(), option)
            end
        end,
        selectedColors = params.selectedColors,
        unselectedColors = params.unselectedColors,
        textColor = params.textColor,
    })

    -- Assumes callers ensure at least one option exists when defaultToFirst is true.
    selector.SetOptionsWithDefault = function(self, options, defaultToFirst)
        self:SetOptions(options or {})
        if defaultToFirst and self.buttons and self.buttons[1] then
            self.buttons[1]:Select()
            selectedValue = self.buttons[1]:OptionValue()
            if params.onSelect then
                params.onSelect(selectedValue, self.buttons[1])
            end
        end
    end

    function selector:GetSelected()
        return selectedValue
    end

    return selector
end

---------------------------------------------------------------------------------------------------
-- Layout Integration -------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------

function PanelKit.VerticalLayout(params)
    return LayoutManager.VerticalLayout(params)
end

function PanelKit.AutoSizedDialog(params)
    -- Callback-based approach to handle the two-stage creation internally
    assert(params.width, "AutoSizedDialog requires width")
    assert(params.buildContent, "AutoSizedDialog requires buildContent callback")
    
    local width = params.width
    local layoutConfig = {
        padding = params.padding or 15,
        spacing = params.spacing or 12,
        chromeOverhead = params.chromeOverhead or 100,
    }
    
    -- Stage 1: Collect layout requirements via callback with mock layout
    local layoutElements = LayoutManager.Elements
    local measuredElements = {}

    local function recordElement(element)
        table.insert(measuredElements, element)
    end

    local mockLayout = {
        AddTitle = function(p)
            recordElement(layoutElements.Title(p or {}))
            return { SetText = function() end }
        end,
        AddSection = function(p)
            recordElement(layoutElements.Section(p or {}))
            return {
                content = { SetText = function() end },
                label = { SetText = function() end }
            }
        end,
        AddSpacer = function(height)
            recordElement(layoutElements.Spacer({ height = height or layoutConfig.spacing }))
        end,
        AddButtonRow = function(p)
            recordElement(layoutElements.ButtonRow(p or {}))
            return {}
        end,
    }
    
    -- Call buildContent with mock layout to collect requirements
    local contentRefs = params.buildContent(mockLayout)
    
    -- Stage 2: Calculate required height
    local requiredHeight = PanelKit.CalculateVerticalLayoutHeight({
        elements = measuredElements,
        padding = layoutConfig.padding,
        spacing = layoutConfig.spacing,
        chromeOverhead = layoutConfig.chromeOverhead,
    })
    
    -- Stage 3: Create properly sized dialog
    local dialog = PanelKit.Dialog({
        id = params.id,
        ui = params.ui or Ui.Get2d(),
        rectAlignment = params.rectAlignment or "MiddleCenter",
        width = width,
        height = requiredHeight,
        color = params.color or "#00000000",
        closeButton = params.closeButton,
    })
    
    local panel = dialog:Panel()
    local chrome = PanelKit.ClassicDialog({
        panel = panel,
        id = params.id,
        width = width,
        height = requiredHeight,
        title = params.title or "",
        subtitle = params.subtitle or "",
        closeButton = params.closeButton,
    })
    
    -- Stage 4: Create real layout and build content
    local layout = PanelKit.VerticalLayout({
        parent = panel,
        contentArea = chrome,
        padding = layoutConfig.padding,
        spacing = layoutConfig.spacing,
    })
    
    local actualRefs = params.buildContent(layout)
    
    return {
        dialog = dialog,
        panel = panel,
        chrome = chrome,
        layout = layout,
        contentRefs = actualRefs,
    }
end

function PanelKit.CalculateVerticalLayoutHeight(params)
    params = params or {}
    local calculatedHeight = LayoutManager.CalculateLayoutHeight(params)
    local extraSafetyPadding = params.extraSafetyPadding or 150

    if _G.log and _G.log.Debugf then
        _G.log:Debugf(
            "Height calc: calculated=%d, chromeOverhead=%d, safety=%d",
            calculatedHeight,
            params.chromeOverhead or 40,
            extraSafetyPadding
        )
    end

    return calculatedHeight + extraSafetyPadding
end

---------------------------------------------------------------------------------------------------

return PanelKit
