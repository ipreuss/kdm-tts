local Check = require("Kdm/Util/Check")
local Container = require("Kdm/Util/Container")
local Expansion = require("Kdm/Expansion")
local Location = require("Kdm/Location")
local log = require("Kdm/Log").ForModule("Archive")
local NamedObject = require("Kdm/NamedObject")
local ObjectState = require("Kdm/Util/ObjectState")
local Util = require("Kdm/Util/Util")

---------------------------------------------------------------------------------------------------

local Archive = {}

Archive.data = {
    { "Abilities", "Abilities", "Abilities Archive" },
    { "Fighting Arts", "Fighting Arts", "Fighting Arts Archive" },
    { "Secret Fighting Arts", "Secret Fighting Arts", "Secret Fighting Arts Archive" },
    { "Disorders", "Disorders", "Disorders Archive" },
    { "Severe Injuries", "Severe Injuries", "Severe Injuries Archive" },
    { "Tactics", "Tactics", "Tactics Archive" },
    { "Weapon Proficiencies", "Weapon Proficiencies", "Weapon Proficiencies Archive" },
    { "Armor Sets", "Armor Sets", "Armor Sets Archive" },
    { "Vermin", "Vermin", "Vermin Archive" },
    { "Strange Resources", "Strange Resources", "Strange Resources Archive" },
    { "Basic Resources", "Basic Resources", "Basic Resources Archive" },
    { "Terrain", "Terrain", "Terrain Archive" },
    { "Terrain Tiles", "Terrain Tiles", "Terrain Tiles Archive" },
    { "Hunt Events", "Hunt Events", "Hunt Events Archive" },
    { "Settlement Events", "Settlement Events", "Settlement Events Archive" },
    { "Future Settlement Events", "Settlement Events", "Future Settlement Events Archive"},
    { "Rare Gear", "Gear", "Rare Gear Archive" },
    { "Seed Pattern Gear", "Gear", "Seed Pattern Gear Archive" },
    { "All Gear", "Gear", "All Gear Archive" },
    { "Monster Resources", "Monster Resources", "Monster Resources Archive" },
    { "Survivor Sheet", "Survivor Sheet", "Survivor Sheets Archive" },
    { "Survivor Box", "Survivor Box", "Survivor Boxes Archive" },
    { "Dodge Tokens", "Survival Tokens", "Dodge Tokens" },
    { "Encourage Tokens", "Survival Tokens", "Encourage Tokens" },
    { "Embolden Tokens", "Survival Tokens", "Embolden Tokens" },
    { "Dash Tokens", "Survival Tokens", "Dash Tokens" },
    { "Surge Tokens", "Survival Tokens", "Surge Tokens" },
    { "Overcharge Tokens", "Survival Tokens", "Overcharge Tokens" },
    { "Endure Tokens", "Survival Tokens", "Endure Tokens" },
    { "Movement Tokens", "Tokens", "Movement Tokens" },
    { "Damage Tokens", "Tokens", "Damage Tokens"},
    { "Toughness Tokens", "Tokens", "Toughness Tokens"},
    { "Speed Tokens", "Tokens", "Speed Tokens"},
    { "Accuracy Tokens", "Tokens", "Accuracy Tokens"},
    { "Strength Tokens", "Tokens", "Strength Tokens"},
    { "Evasion Tokens", "Tokens", "Evasion Tokens"},
    { "Luck Tokens", "Tokens", "Luck Tokens"},
    { "Allister", "Player Figurine", "Allister Archive" },
    { "Ezra", "Player Figurine", "Ezra Archive" },
    { "Lucy", "Player Figurine", "Lucy Archive" },
    { "Zachary", "Player Figurine", "Zachary Archive" },
    { "Seed Patterns", "Seed Patterns", "Seed Patterns Archive"},
    { "Character - Abilities", "Character", "Character Archive - Abilities"},
    { "Character - Impairments", "Character", "Character Archive - Impairments"},
    { "Character - Legendary Abilities", "Character", "Character Archive - Legendary Abilities"},
    { "Character", "Character", "Character Archive"},
    { "Bookmarks", "Bookmarks", "Bookmarks Archive"},
    { "Counter", "Counter", "Counter Archive"},
    { "Random Hunt Events", "Hunt Events", "Random Hunt Events Archive" },
    { "Evolving Hunt Events", "Hunt Events", "Evolving Hunt Events Archive"},
 
}

---------------------------------------------------------------------------------------------------

function Archive.Init()
    Archive.index = {}
    Archive.keysByType = {}
    Archive.direct = {}

    -- "Direct" entries are the items directly contained by the infinite container archive, such as the "Disorders" deck in the "Disorders Archive".
    -- For such items we just a flag telling us to take the item directly, no need to search inside it.
    for _, entry in ipairs(Archive.data) do
        local name, type, archive = entry[1], entry[2], entry[3]
        local key = Archive.Key(name, type)
        Archive.RegisterIndexEntry(key, archive, name, type)
        Archive.direct[key] = true
    end

    Archive.containers = {}
    Archive.containerX = -150
    Archive.containerZ = 120

    for _, expansion in ipairs(Expansion.All()) do
        Archive.RegisterEntries(expansion.archiveEntries)
    end
end

function Archive.CreateAllGearDeck()
    Archive.Clean()
    log:Debugf("creating all gear deck")
    local objects = {}
    for _, expansion in ipairs(Expansion.All(Expansion.EnabledFilter)) do
        for _, entry in ipairs(expansion.archiveEntries.entries) do
            local name, type = entry[1], entry[2]
            if type == "Gear" then
                log:Debugf("taking gear deck %s", name)
                local deck = Archive.Take({ name = name, type = "Gear", position = Archive.NextContainerPosition()})
                table.insert(objects, deck)
            end
        end
    end
    log:Debugf("#decks for gear deck: %d", #objects)
    local deck = Archive.CreateDeckFromTable(objects)
    deck.setName("All Gear")
    
    local function CheckForDuplicates(deck)
        local cardCounts = {}
        local duplicates = {}

        for _, card in ipairs(deck.getObjects()) do
            local cardName = card.name
            log:Debugf("Checking card: %s", cardName)
            cardCounts[cardName] = (cardCounts[cardName] or 0) + 1

            if cardCounts[cardName] > 1 then
                table.insert(duplicates, cardName)
            end
        end

        for _, duplicate in ipairs(duplicates) do
            log:Errorf("Duplicate card found: %s", duplicate)
        end
    end

    -- Call the function to check for duplicates in the "All Gear" deck
    CheckForDuplicates(deck)

    log:Debugf("putting all gear deck in archive")
    local archive = NamedObject.Get("All Gear Archive")
    archive.reset()
    archive.putObject(deck)
    Archive.Clean()
end

---------------------------------------------------------------------------------------------------

function Archive.Key(name, type)
    return type.."."..name
end

---------------------------------------------------------------------------------------------------

function Archive.RegisterIndexEntry(key, archive, name, type)
    Archive.index[key] = archive
    Archive.keysByType[type] = Archive.keysByType[type] or {}
    Archive.keysByType[type][key] = name
end

function Archive.RegisterEntries(params)
    if not params then
        return
    end

    local archive = params.archive
    assert(archive)
    for _, entry in ipairs(params.entries) do
        local name, type = entry[1], entry[2]
        assert(name)
        assert(type)
        local key = Archive.Key(name, type)
        if not params.allowOverrides then
            assert(Check(Archive.index[key] == nil, "Archive entry %s/%s for %s is already registered for %s", name, type, archive, Archive.index[key]))
        end
        Archive.RegisterIndexEntry(key, archive, name, type)
    end
end

---------------------------------------------------------------------------------------------------

function Archive.NextContainerPosition()
    local position = { x = Archive.containerX, y = 15, z = Archive.containerZ }
    Archive.containerX = Archive.containerX + 10
    if Archive.containerX > 150 then
        Archive.containerX = -150
        Archive.containerZ = Archive.containerZ - 10
        if Archive.containerZ < 70 then
            Archive.containerZ = 120
        end
    end
    return position
end

---------------------------------------------------------------------------------------------------

function CalculatePosition(params)
    if not params.location then
        assert(Check.Vec3(params.position, "Either location or position is required"))
        return params.position
    end
    local height = params.height or 2
    local location = Location.Get(params.location)
    local position = location:Center()
    position.y = position.y + height
    return position
end

---------------------------------------------------------------------------------------------------

local function stripTrailingBracketSuffix(value)
    return ObjectState.StripTrailingBracketSuffix(value)
end

local function applyStateByName(object, stateName)
    log:Debugf("[DEBUG] applyStateByName START object=%s, stateName=%s", tostring(object), tostring(stateName))
    if not stateName or not object then
        log:Debugf("[DEBUG] applyStateByName: no stateName or no object, returning")
        return object
    end
    if type(object.getStates) ~= "function" or type(object.setState) ~= "function" then
        log:Debugf("[DEBUG] applyStateByName: object doesn't have state methods, returning")
        return object
    end
    local states = object.getStates()
    log:Debugf("[DEBUG] applyStateByName: got states, type=%s", type(states))
    return ObjectState.ApplyStateByName(object, stateName)
end

local function wrapSpawnFunc(spawnFunc, stateName)
    if not spawnFunc or not stateName then
        return spawnFunc
    end
    return function(obj, ...)
        obj = applyStateByName(obj, stateName)
        spawnFunc(obj, ...)
    end
end

function Archive.TakeObject(params) 
    local archiveParams = {}
    for key, value in pairs(params) do
        archiveParams[key] = value
    end
    archiveParams.lenient = true
    for key, _ in pairs(Archive.keysByType[params.type] or {}) do
        archiveParams.archive = Archive.index[key]
        local object = Archive.Take(archiveParams)
        if object then
            return object
        end
    end
    assert(Check(false, "Couldn't find object %s/%s", params.name, params.type))
end

function Archive.Take(params)
    local archive = params.archive
    local requestedName = params.name
    local type = params.type
    local position = CalculatePosition(params)

    local rotation = params.rotation or { x = 0, y = 180, z = 0 }
    local spawnFunc = params.spawnFunc
    local directKey = nil
    assert(Check.StrOrNil(archive))
    assert(Check.StrOrNil(requestedName))
    assert(Check.StrOrNil(type))
    assert(Check.Vec3OrNil(rotation))
    assert(Check.FuncOrNil(spawnFunc))

    local strippedName = requestedName and stripTrailingBracketSuffix(requestedName) or nil
    if strippedName == requestedName then
        strippedName = nil
    end

    local nameCandidates = {}
    if requestedName then
        table.insert(nameCandidates, requestedName)
    end
    if strippedName and strippedName ~= requestedName then
        table.insert(nameCandidates, strippedName)
    end

    local resolvedName = requestedName
    local archiveKey = params.key
    if not archive then
        for _, candidate in ipairs(nameCandidates) do
            local candidateKey = params.key or (candidate and Archive.Key(candidate, type))
            local candidateArchive = candidateKey and Archive.index[candidateKey] or nil
            if candidateArchive then
                archive = candidateArchive
                resolvedName = candidate
                archiveKey = candidateKey
                directKey = candidateKey
                break
            end
        end

        if not archive then
            if params.lenient then
                log:Debugf("Archive not found for %s, returning nil", archiveKey or "<nil>")
                return nil
            end
            assert(Check(false, "Couldn't find archive for %s (%s)", requestedName, type))
        end
    end

    local function prepareSpawn(stateName)
        if not stateName then
            return spawnFunc, false
        end
        if not spawnFunc then
            return nil, false
        end
        return wrapSpawnFunc(spawnFunc, stateName), true
    end

    local function takeDirect(stateName)
        log:Debugf("Using direct from archive %s for %s ", archive, archiveKey)
        local spawnWrapper, appliedInSpawn = prepareSpawn(stateName)
        local object = NamedObject.Get(archive).takeObject({
            position = position,
            rotation = rotation,
            smooth = params.smooth,
            callback_function = spawnWrapper,
        })
        local applyOnReturn = (stateName and not appliedInSpawn) and stateName or nil
        return applyStateByName(object, applyOnReturn)
    end

    local function ensureContainer()
        local container = Archive.containers[archive]
        log:Debugf("[DEBUG] ensureContainer: archive=%s, cached=%s, isEmpty=%s", 
            archive, 
            tostring(container ~= nil),
            container and tostring(container:IsEmpty()) or "N/A")
        if container and not container:IsEmpty() then
            log:Debugf("Re-using already-spawned archive container %s for %s (%s)", container:Guid(), resolvedName, type)
            return container
        end
        
        log:Debugf("[DEBUG] ensureContainer: spawning fresh container from archive")
        local archiveObject = NamedObject.Get(archive)
        log:Debugf("[DEBUG] ensureContainer: archiveObject=%s", tostring(archiveObject))
        local containerObject = archiveObject.takeObject({
            position = Archive.NextContainerPosition(),
            smooth = false,
        })
        log:Debugf("[DEBUG] ensureContainer: containerObject=%s", tostring(containerObject))
        container = Container(containerObject)
        log:Debugf("[DEBUG] ensureContainer: container=%s", tostring(container))
        if not container then
            log:Errorf("Couldn't take from archive [%s] %s.", archiveObject.getGUID(), archiveObject.getName())
            Util.Highlight(archiveObject)
            return nil
        end

        log:Debugf("Spawned archive container %s at (%f, %f) for %s (%s)", "", Archive.containerX, Archive.containerZ, resolvedName, type)
        Archive.containers[archive] = container
        return container
    end

    if directKey and Archive.direct[directKey] then
        local stateName = (resolvedName ~= requestedName) and requestedName or nil
        return takeDirect(stateName)
    end

    log:Debugf("Taking item %s (%s) in archive %s to %s", resolvedName or "<nil>", type, archive, position)
    local container = ensureContainer()
    log:Debugf("[DEBUG] After ensureContainer: container=%s", tostring(container))
    if not container then
        return nil
    end

    local attemptedNames = {}
    local function queueName(candidate)
        if not candidate then
            return
        end
        for _, existing in ipairs(attemptedNames) do
            if existing == candidate then
                return
            end
        end
        table.insert(attemptedNames, candidate)
    end

    queueName(resolvedName)
    for _, candidate in ipairs(nameCandidates) do
        queueName(candidate)
    end

    local object
    local usedStateName = nil
    log:Debugf("[DEBUG] About to iterate attemptedNames: %s", Util.TabStr(attemptedNames))
    log:Debugf("[DEBUG] container.object=%s, tag=%s", tostring(container.object), container.object and container.object.tag or "<nil>")
    for _, candidate in ipairs(attemptedNames) do
        log:Debugf("[DEBUG] Trying candidate: %s, type: %s", candidate, type or "<nil>")
        local needsState = requestedName ~= nil and candidate ~= requestedName
        local stateName = needsState and requestedName or nil
        local spawnWrapper, appliedInSpawn = prepareSpawn(stateName)
        object = container:Take({
            name = candidate,
            type = type,
            position = position,
            rotation = rotation,
            spawnFunc = spawnWrapper,
            smooth = params.smooth,
        })
        log:Debugf("[DEBUG] container:Take returned object=%s", tostring(object))
        if object then
            log:Debugf("[DEBUG] object found, stateName=%s, appliedInSpawn=%s", tostring(stateName), tostring(appliedInSpawn))
            if stateName and not appliedInSpawn then
                usedStateName = stateName
            else
                usedStateName = nil
            end
            log:Debugf("[DEBUG] breaking loop, usedStateName=%s", tostring(usedStateName))
            break
        end
    end

    log:Debugf("[DEBUG] after loop, object=%s", tostring(object))
    if not object then
        log:Debugf("[DEBUG] object is nil, lenient=%s", tostring(params.lenient))
        if params.lenient then
            log:Debugf("Couldn't find %s (%s) in archive %s, returning nil", requestedName or "<nil>", type, archive)
            return nil
        end
        Util.Highlight(NamedObject.Get(archive))
        assert(Check(false,
            "Couldn't find %s (%s) in archive %s.",
            requestedName, type, archive))
    end

    log:Debugf("[DEBUG] about to call applyStateByName, object=%s, usedStateName=%s", tostring(object), tostring(usedStateName))
    return applyStateByName(object, usedStateName)
end

---------------------------------------------------------------------------------------------------

function Archive.ArchiveSource(name, type)
    return {
        source = "Archive",
        name = name,
        type = type,
    }
end

---------------------------------------------------------------------------------------------------

function Archive.ContainerSource(container, name, type)
    return {
        source = "Container",
        container = container,
        name = name,
        type = type,
    }
end

---------------------------------------------------------------------------------------------------

function Archive.CreateDeckFromSources(params)
    local sources, location, rotation = params.sources, Location.Get(params.location), params.rotation or { x = 0, y = 180, z = 0 }

    local objects = {}
    for i, source in ipairs(sources) do
        local takeParams = { name = source.name, type = source.type, position = location:Position((i - 1) * 0.5), rotation = rotation }
        local object = nil
        if source.source == "Archive" then
            log:Debugf("Taking %s/%s from archive", source.name, source.type)
            object = Archive.Take(takeParams)
            assert(object or params.ignoreMissingCards, "Couldn't find "..source.name.." in archive")
        elseif source.source == "Container" then
            log:Debugf("Taking %s/%s from container", source.name, source.type)
            object = source.container:Take(takeParams)
            assert(Check(object or params.ignoreMissingCards, "Couldn't find %s in container %s", source.name, source.container:Name()))
        else
            assert(Check.Fail("Unrecognized source: %s", source))
        end
        table.insert(objects, object)
    end

    local deckObject = Archive.CreateDeckFromTable(objects)

    deckObject.setName(params.name)
    deckObject.setGMNotes(params.type)
    deckObject.setPositionSmooth(location:Center(), false, true)
    deckObject.setRotation(rotation)

    return Container(deckObject)
end

function Archive.CreateDeckFromTable(objects)
    if #objects > 1 then
        return group(objects)[1]
    else
        return objects[1]
    end

end
---------------------------------------------------------------------------------------------------

function Archive.Clean()
    for _, container in pairs(Archive.containers) do
        --log:Debugf("Destroying archive container %s", container:Guid())
        container:Destruct()
    end

    -- scan and clean orphaned containers from a previous error
    local hits = Physics.cast({
        origin    = { x = 0, y = 100, z = 95 },
        direction = { x = 0, y = -1, z = 0 },
        type      = 3,
        size      = { x = 350, y = 50, z = 100 },
    })
    for _, hit in ipairs(hits) do
        local obj = hit.hit_object
        assert(obj, "Physics.cast returned hit with nil hit_object")
        if obj.tag == "Bag" and obj.getGMNotes() == "Archive Bag" then
            --log:Debugf("Destroying leftover archive bag %s (%s)", obj.getName(), obj.getGUID())
            obj.destruct()
        end
        if obj.tag == "Deck" then
            local key = Archive.Key(obj.getName(), obj.getGMNotes())
            if Archive.direct[key] then
                --log:Debugf("Destroying leftover archive deck %s (%s)", obj.getName(), obj.getGUID())
                obj.destruct()
            end
        end
    end

    Archive.containers = {}
    Archive.containerX = -150
    Archive.containerZ = 120
end

---------------------------------------------------------------------------------------------------

return {
    Init = Archive.Init,
    RegisterEntries = Archive.RegisterEntries,
    Take = Archive.Take,
    TakeObject = Archive.TakeObject,
    ArchiveSource = Archive.ArchiveSource,
    ContainerSource = Archive.ContainerSource,
    CreateDeckFromSources = Archive.CreateDeckFromSources,
    Clean = Archive.Clean,
    CreateAllGearDeck = Archive.CreateAllGearDeck,
}
