local Check = require("Kdm/Util/Check")
local Container = require("Kdm/Util/Container")
local Expansion = require("Kdm/Expansion")
local Location = require("Kdm/Location")
local log = require("Kdm/Log").ForModule("Archive")
local NamedObject = require("Kdm/NamedObject")
local ObjectState = require("Kdm/Util/ObjectState")
local TTSSpawner = require("Kdm/Util/TTSSpawner")
local Util = require("Kdm/Util/Util")

---------------------------------------------------------------------------------------------------

local Archive = {}

---------------------------------------------------------------------------------------------------
-- Test seam: allows tests to inject fake spawner for integration testing without TTS
---------------------------------------------------------------------------------------------------

Archive._spawner = nil

function Archive.Test_SetSpawner(spawner)
    Archive._spawner = spawner
end

function Archive.Test_ResetSpawner()
    Archive._spawner = nil
end

local function getSpawner()
    return Archive._spawner or TTSSpawner
end

---------------------------------------------------------------------------------------------------

Archive.data = {
    { "Abilities", "Abilities", "Abilities Archive" },
    { "Fighting Arts", "Fighting Arts", "Fighting Arts Archive" },
    { "Secret Fighting Arts", "Secret Fighting Arts", "Secret Fighting Arts Archive" },
    { "Disorders", "Disorders", "Disorders Archive" },
    { "Severe Injuries", "Severe Injuries", "Severe Injuries Archive" },
    { "Tactics", "Tactics", "Tactics Archive" },
    { "Weapon Proficiencies", "Weapon Proficiencies", "Weapon Proficiencies Archive" },
    { "Armor Sets", "Armor Sets", "Armor Sets Archive" },
    { "Vermin", "Vermin", "Vermin Archive" },
    { "Strange Resources", "Strange Resources", "Strange Resources Archive" },
    { "Basic Resources", "Basic Resources", "Basic Resources Archive" },
    { "Terrain", "Terrain", "Terrain Archive" },
    { "Terrain Tiles", "Terrain Tiles", "Terrain Tiles Archive" },
    { "Hunt Events", "Hunt Events", "Hunt Events Archive" },
    { "Settlement Events", "Settlement Events", "Settlement Events Archive" },
    { "Future Settlement Events", "Settlement Events", "Future Settlement Events Archive"},
    { "Rare Gear", "Gear", "Rare Gear Archive" },
    { "Seed Pattern Gear", "Gear", "Seed Pattern Gear Archive" },
    { "Pattern Gear", "Gear", "Pattern Gear Archive" },
    { "All Gear", "Gear", "All Gear Archive" },
    { "Monster Resources", "Monster Resources", "Monster Resources Archive" },
    { "Survivor Sheet", "Survivor Sheet", "Survivor Sheets Archive" },
    { "Survivor Box", "Survivor Box", "Survivor Boxes Archive" },
    { "Dodge Tokens", "Survival Tokens", "Dodge Tokens" },
    { "Encourage Tokens", "Survival Tokens", "Encourage Tokens" },
    { "Embolden Tokens", "Survival Tokens", "Embolden Tokens" },
    { "Dash Tokens", "Survival Tokens", "Dash Tokens" },
    { "Surge Tokens", "Survival Tokens", "Surge Tokens" },
    { "Overcharge Tokens", "Survival Tokens", "Overcharge Tokens" },
    { "Endure Tokens", "Survival Tokens", "Endure Tokens" },
    { "Movement Tokens", "Tokens", "Movement Tokens" },
    { "Damage Tokens", "Tokens", "Damage Tokens"},
    { "Toughness Tokens", "Tokens", "Toughness Tokens"},
    { "Speed Tokens", "Tokens", "Speed Tokens"},
    { "Accuracy Tokens", "Tokens", "Accuracy Tokens"},
    { "Strength Tokens", "Tokens", "Strength Tokens"},
    { "Evasion Tokens", "Tokens", "Evasion Tokens"},
    { "Luck Tokens", "Tokens", "Luck Tokens"},
    { "Allister", "Player Figurine", "Allister Archive" },
    { "Ezra", "Player Figurine", "Ezra Archive" },
    { "Lucy", "Player Figurine", "Lucy Archive" },
    { "Zachary", "Player Figurine", "Zachary Archive" },
    { "Seed Patterns", "Seed Patterns", "Seed Patterns Archive"},
    { "Patterns", "Patterns", "Patterns Archive"},
    { "Character - Abilities", "Character", "Character Archive - Abilities"},
    { "Character - Impairments", "Character", "Character Archive - Impairments"},
    { "Character - Legendary Abilities", "Character", "Character Archive - Legendary Abilities"},
    { "Character", "Character", "Character Archive"},
    { "Bookmarks", "Bookmarks", "Bookmarks Archive"},
    { "Counter", "Counter", "Counter Archive"},
    { "Random Hunt Events", "Hunt Events", "Random Hunt Events Archive" },
    { "Evolving Hunt Events", "Hunt Events", "Evolving Hunt Events Archive"},
 
}

---------------------------------------------------------------------------------------------------

function Archive.Init()
    Archive.index = {}
    Archive.keysByType = {}
    Archive.direct = {}

    -- "Direct" entries are the items directly contained by the infinite container archive, such as the "Disorders" deck in the "Disorders Archive".
    -- For such items we just a flag telling us to take the item directly, no need to search inside it.
    for _, entry in ipairs(Archive.data) do
        local name, type, archive = entry[1], entry[2], entry[3]
        local key = Archive.Key(name, type)
        Archive.RegisterIndexEntry(key, archive, name, type)
        Archive.direct[key] = true
    end

    Archive.containers = {}
    Archive.containerX = -150
    Archive.containerZ = 120

    for _, expansion in ipairs(Expansion.All()) do
        Archive.RegisterEntries(expansion.archiveEntries)
    end
end

function Archive.CreateAllGearDeck()
    Archive.Clean()
    log:Debugf("creating all gear deck")
    local objects = {}
    for _, expansion in ipairs(Expansion.All(Expansion.EnabledFilter)) do
        for _, entry in ipairs(expansion.archiveEntries.entries) do
            local name, type = entry[1], entry[2]
            if type == "Gear" then
                log:Debugf("taking gear deck %s", name)
                local deck = Archive.Take({ name = name, type = "Gear", position = Archive.NextContainerPosition()})
                table.insert(objects, deck)
            end
        end
    end
    log:Debugf("#decks for gear deck: %d", #objects)
    local deck = Archive.CreateDeckFromTable(objects)
    deck.setName("All Gear")
    
    local function CheckForDuplicates(deck)
        local cardCounts = {}
        local duplicates = {}

        for _, card in ipairs(deck.getObjects()) do
            local cardName = card.name
            log:Debugf("Checking card: %s", cardName)
            cardCounts[cardName] = (cardCounts[cardName] or 0) + 1

            if cardCounts[cardName] > 1 then
                table.insert(duplicates, cardName)
            end
        end

        for _, duplicate in ipairs(duplicates) do
            log:Errorf("Duplicate card found: %s", duplicate)
        end
    end

    -- Call the function to check for duplicates in the "All Gear" deck
    CheckForDuplicates(deck)

    log:Debugf("putting all gear deck in archive")
    local archive = NamedObject.Get("All Gear Archive")
    archive.reset()
    archive.putObject(deck)
    Archive.Clean()
end

---------------------------------------------------------------------------------------------------

function Archive.Key(name, type)
    return type.."."..name
end

---------------------------------------------------------------------------------------------------

function Archive.RegisterIndexEntry(key, archive, name, type)
    Archive.index[key] = archive
    Archive.keysByType[type] = Archive.keysByType[type] or {}
    Archive.keysByType[type][key] = name
end

function Archive.RegisterEntries(params)
    if not params then
        return
    end

    local archive = params.archive
    assert(archive)
    for _, entry in ipairs(params.entries) do
        local name, type = entry[1], entry[2]
        assert(name)
        assert(type)
        local key = Archive.Key(name, type)
        if not params.allowOverrides then
            assert(Check(Archive.index[key] == nil, "Archive entry %s/%s for %s is already registered for %s", name, type, archive, Archive.index[key]))
        end
        Archive.RegisterIndexEntry(key, archive, name, type)
    end
end

---------------------------------------------------------------------------------------------------

function Archive.NextContainerPosition()
    local position = { x = Archive.containerX, y = 15, z = Archive.containerZ }
    Archive.containerX = Archive.containerX + 10
    if Archive.containerX > 150 then
        Archive.containerX = -150
        Archive.containerZ = Archive.containerZ - 10
        if Archive.containerZ < 70 then
            Archive.containerZ = 120
        end
    end
    return position
end

---------------------------------------------------------------------------------------------------

function CalculatePosition(params)
    if not params.location then
        assert(Check.Vec3(params.position, "Either location or position is required"))
        return params.position
    end
    local height = params.height or 2
    local location = Location.Get(params.location)
    local position = location:Center()
    position.y = position.y + height
    return position
end

---------------------------------------------------------------------------------------------------

local function applyStateByName(object, stateName)
    log:Debugf("[DEBUG] applyStateByName START object=%s, stateName=%s", tostring(object), tostring(stateName))
    assert(stateName, "stateName is required - caller should check before calling")
    assert(object, "object is required")
    assert(type(object.getStates) == "function", "object must support getStates() - check archive setup")
    assert(type(object.setState) == "function", "object must support setState() - check archive setup")
    
    local states = object.getStates()
    log:Debugf("[DEBUG] applyStateByName: got states, type=%s", type(states))
    return ObjectState.ApplyStateByName(object, stateName)
end

local function wrapSpawnFunc(spawnFunc, stateName)
    if not spawnFunc or not stateName then
        return spawnFunc
    end
    return function(obj, ...)
        obj = applyStateByName(obj, stateName)
        spawnFunc(obj, ...)
    end
end

function Archive.TakeObject(params) 
    local archiveParams = {}
    for key, value in pairs(params) do
        archiveParams[key] = value
    end
    archiveParams.lenient = true
    for key, _ in pairs(Archive.keysByType[params.type] or {}) do
        archiveParams.archive = Archive.index[key]
        local object = Archive.Take(archiveParams)
        if object then
            return object
        end
    end
    assert(Check(false, "Couldn't find object %s/%s", params.name, params.type))
end

function Archive.Take(params)
    local archive = params.archive
    local requestedName = params.name
    local type = params.type
    local position = CalculatePosition(params)

    local rotation = params.rotation or { x = 0, y = 180, z = 0 }
    local spawnFunc = params.spawnFunc
    local directKey = nil
    assert(Check.StrOrNil(archive))
    assert(Check.StrOrNil(requestedName))
    assert(Check.StrOrNil(type))
    assert(Check.Vec3OrNil(rotation))
    assert(Check.FuncOrNil(spawnFunc))

    local strippedName = requestedName and ObjectState.StripTrailingBracketSuffix(requestedName) or nil
    if strippedName == requestedName then
        strippedName = nil
    end

    local nameCandidates = {}
    if requestedName then
        table.insert(nameCandidates, requestedName)
    end
    if strippedName and strippedName ~= requestedName then
        table.insert(nameCandidates, strippedName)
    end

    local resolvedName = requestedName
    local archiveKey = params.key
    if not archive then
        for _, candidate in ipairs(nameCandidates) do
            local candidateKey = params.key or (candidate and Archive.Key(candidate, type))
            local candidateArchive = candidateKey and Archive.index[candidateKey] or nil
            if candidateArchive then
                archive = candidateArchive
                resolvedName = candidate
                archiveKey = candidateKey
                directKey = candidateKey
                break
            end
        end

        if not archive then
            if params.lenient then
                log:Debugf("Archive not found for %s, returning nil", archiveKey or "<nil>")
                return nil
            end
            assert(Check(false, "Couldn't find archive for %s (%s)", requestedName, type))
        end
    end

    local function prepareSpawn(stateName)
        if not stateName then
            return spawnFunc, false
        end
        if not spawnFunc then
            return nil, false
        end
        return wrapSpawnFunc(spawnFunc, stateName), true
    end

    local function takeDirect(stateName)
        log:Debugf("Using direct from archive %s for %s ", archive, archiveKey)
        local spawnWrapper, appliedInSpawn = prepareSpawn(stateName)
        local spawner = getSpawner()
        local object = spawner.TakeFromArchive(NamedObject.Get(archive), {
            position = position,
            rotation = rotation,
            smooth = params.smooth,
            callback_function = spawnWrapper,
        })
        -- Only apply state if needed (not already applied in spawn callback)
        if stateName and not appliedInSpawn then
            return applyStateByName(object, stateName)
        end
        return object
    end

    local function ensureContainer()
        local container = Archive.containers[archive]
        log:Debugf("[DEBUG] ensureContainer: archive=%s, cached=%s, isEmpty=%s", 
            archive, 
            tostring(container ~= nil),
            container and tostring(container:IsEmpty()) or "N/A")
        if container and not container:IsEmpty() then
            log:Debugf("Re-using already-spawned archive container %s for %s (%s)", container:Guid(), resolvedName, type)
            return container
        end
        
        log:Debugf("[DEBUG] ensureContainer: spawning fresh container from archive")
        local archiveObject = NamedObject.Get(archive)
        log:Debugf("[DEBUG] ensureContainer: archiveObject=%s", tostring(archiveObject))
        local spawner = getSpawner()
        local containerObject = spawner.TakeFromArchive(archiveObject, {
            position = Archive.NextContainerPosition(),
            smooth = false,
        })
        log:Debugf("[DEBUG] ensureContainer: containerObject=%s", tostring(containerObject))
        container = Container(containerObject)
        log:Debugf("[DEBUG] ensureContainer: container=%s", tostring(container))
        if not container then
            log:Errorf("Couldn't take from archive [%s] %s.", archiveObject.getGUID(), archiveObject.getName())
            Util.Highlight(archiveObject)
            return nil
        end

        log:Debugf("Spawned archive container %s at (%f, %f) for %s (%s)", "", Archive.containerX, Archive.containerZ, resolvedName, type)
        Archive.containers[archive] = container
        return container
    end

    if directKey and Archive.direct[directKey] then
        local stateName = (resolvedName ~= requestedName) and requestedName or nil
        return takeDirect(stateName)
    end

    log:Debugf("Taking item %s (%s) in archive %s to %s", resolvedName or "<nil>", type, archive, position)
    local container = ensureContainer()
    log:Debugf("[DEBUG] After ensureContainer: container=%s", tostring(container))
    if not container then
        return nil
    end

    local attemptedNames = {}
    local function queueName(candidate)
        if not candidate then
            return
        end
        for _, existing in ipairs(attemptedNames) do
            if existing == candidate then
                return
            end
        end
        table.insert(attemptedNames, candidate)
    end

    queueName(resolvedName)
    for _, candidate in ipairs(nameCandidates) do
        queueName(candidate)
    end

    local object
    local usedStateName = nil
    log:Debugf("[DEBUG] About to iterate attemptedNames: %s", Util.TabStr(attemptedNames))
    log:Debugf("[DEBUG] container.object=%s, tag=%s", tostring(container.object), container.object and container.object.tag or "<nil>")
    for _, candidate in ipairs(attemptedNames) do
        log:Debugf("[DEBUG] Trying candidate: %s, type: %s", candidate, type or "<nil>")
        local needsState = requestedName ~= nil and candidate ~= requestedName
        local stateName = needsState and requestedName or nil
        local spawnWrapper, appliedInSpawn = prepareSpawn(stateName)
        object = container:Take({
            name = candidate,
            type = type,
            position = position,
            rotation = rotation,
            spawnFunc = spawnWrapper,
            smooth = params.smooth,
        })
        log:Debugf("[DEBUG] container:Take returned object=%s", tostring(object))
        if object then
            log:Debugf("[DEBUG] object found, stateName=%s, appliedInSpawn=%s", tostring(stateName), tostring(appliedInSpawn))
            if stateName and not appliedInSpawn then
                usedStateName = stateName
            else
                usedStateName = nil
            end
            log:Debugf("[DEBUG] breaking loop, usedStateName=%s", tostring(usedStateName))
            break
        end
    end

    log:Debugf("[DEBUG] after loop, object=%s", tostring(object))
    if not object then
        log:Debugf("[DEBUG] object is nil, lenient=%s", tostring(params.lenient))
        if params.lenient then
            log:Debugf("Couldn't find %s (%s) in archive %s, returning nil", requestedName or "<nil>", type, archive)
            return nil
        end
        Util.Highlight(NamedObject.Get(archive))
        assert(Check(false,
            "Couldn't find %s (%s) in archive %s.",
            requestedName, type, archive))
    end

    log:Debugf("[DEBUG] about to call applyStateByName, object=%s, usedStateName=%s", tostring(object), tostring(usedStateName))
    if usedStateName then
        return applyStateByName(object, usedStateName)
    end
    return object
end

---------------------------------------------------------------------------------------------------

function Archive.TakeFromDeck(params)
    assert(Check.Str(params.deckName, "deckName is required"))
    assert(Check.Str(params.name, "card name is required"))
    assert(Check.Table(params.position, "position is required"))
    
    log:Debugf("[DEBUG] TakeFromDeck START deckName='%s', cardName='%s'", params.deckName, params.name)
    
    -- Take the deck from archive
    local deckParams = {
        name = params.deckName,
        type = params.deckType,
        position = params.deckStagingPosition or { x = 0, y = 10, z = 0 },
        rotation = { x = 0, y = 180, z = 180 },
        lenient = true,
    }
    
    local deck = Archive.Take(deckParams)
    assert(deck, Util.SafeFormat("Deck '%s' not found in archive - check mod setup", params.deckName))
    
    local deckContainer = Container(deck)
    assert(deckContainer, Util.SafeFormat("Unable to create container for deck '%s' - invalid TTS object", params.deckName))
    
    -- Log contents for debugging
    if log.level == "DEBUG" then
        log:Debugf("[DEBUG] Contents of deck '%s':", params.deckName)
        for _, entry in ipairs(deckContainer:Objects()) do
            log:Debugf("[DEBUG]   - name='%s', gm_notes='%s', guid='%s'", entry.name, entry.gm_notes or "<nil>", entry.guid)
        end
    end
    log:Debugf("[DEBUG] Looking for card name='%s', type='%s'", params.name, params.cardType or "<any>")
    
    -- Try to take card from deck
    local function takeCardCandidate(targetName, desiredStateName)
        assert(targetName, "targetName is required")
        
        local object = deckContainer:Take({
            name = targetName,
            type = params.cardType,
            position = params.position,
            rotation = params.rotation,
        })
        if not object then
            return nil  -- Card not in deck - legitimate case for fallback logic
        end
        
        if desiredStateName then
            object = ObjectState.ApplyStateByName(object, desiredStateName)
        end
        if params.spawnFunc then
            params.spawnFunc(object)
        end
        return object
    end
    
    -- First attempt: try requested name
    local card = takeCardCandidate(params.name)
    log:Debugf("[DEBUG] First attempt returned: %s", tostring(card))
    
    -- Fallback: strip state suffix and look for base card
    if not card then
        local strippedName = ObjectState.StripTrailingBracketSuffix(params.name)
        if strippedName ~= params.name then
            log:Debugf("[DEBUG] Fallback from '%s' to '%s'", params.name, strippedName)
            card = takeCardCandidate(strippedName, params.name)
            log:Debugf("[DEBUG] Fallback returned: %s", tostring(card))
        end
    end
    
    -- Cleanup
    deck.destruct()
    Archive.Clean()
    
    if not card then
        log:Errorf("Card '%s' not found in deck '%s'", params.name, params.deckName)
        return false
    end
    
    return true
end

---------------------------------------------------------------------------------------------------

function Archive.ArchiveSource(name, type)
    return {
        source = "Archive",
        name = name,
        type = type,
    }
end

---------------------------------------------------------------------------------------------------

function Archive.ContainerSource(container, name, type)
    return {
        source = "Container",
        container = container,
        name = name,
        type = type,
    }
end

---------------------------------------------------------------------------------------------------

function Archive.CreateDeckFromSources(params)
    local sources, location, rotation = params.sources, Location.Get(params.location), params.rotation or { x = 0, y = 180, z = 0 }

    local objects = {}
    for i, source in ipairs(sources) do
        local takeParams = { name = source.name, type = source.type, position = location:Position((i - 1) * 0.5), rotation = rotation }
        local object = nil
        if source.source == "Archive" then
            log:Debugf("Taking %s/%s from archive", source.name, source.type)
            object = Archive.Take(takeParams)
            assert(object or params.ignoreMissingCards, "Couldn't find "..source.name.." in archive")
        elseif source.source == "Container" then
            log:Debugf("Taking %s/%s from container", source.name, source.type)
            object = source.container:Take(takeParams)
            assert(Check(object or params.ignoreMissingCards, "Couldn't find %s in container %s", source.name, source.container:Name()))
        else
            assert(Check.Fail("Unrecognized source: %s", source))
        end
        table.insert(objects, object)
    end

    local deckObject = Archive.CreateDeckFromTable(objects)

    deckObject.setName(params.name)
    deckObject.setGMNotes(params.type)
    deckObject.setPositionSmooth(location:Center(), false, true)
    deckObject.setRotation(rotation)

    return Container(deckObject)
end

function Archive.CreateDeckFromTable(objects)
    if #objects > 1 then
        return group(objects)[1]
    else
        return objects[1]
    end

end
---------------------------------------------------------------------------------------------------

function Archive.Clean()
    for _, container in pairs(Archive.containers) do
        container:Destruct()
    end

    -- scan and clean orphaned containers from a previous error
    local hits = Physics.cast({
        origin    = { x = 0, y = 100, z = 95 },
        direction = { x = 0, y = -1, z = 0 },
        type      = 3,
        size      = { x = 350, y = 50, z = 100 },
    })
    for _, hit in ipairs(hits) do
        local obj = hit.hit_object
        assert(obj, "Physics.cast returned hit with nil hit_object")
        if obj.tag == "Bag" and obj.getGMNotes() == "Archive Bag" then
            obj.destruct()
        end
        if obj.tag == "Deck" then
            local key = Archive.Key(obj.getName(), obj.getGMNotes())
            if Archive.direct[key] then
                obj.destruct()
            end
        end
    end

    -- Clean up Strain Rewards deck at staging position (-150, 15, 120)
    -- This deck is spawned by FightingArtsArchive/VerminArchive/BasicResourcesArchive
    -- and should be cleaned up after all operations are complete
    local stagingHits = Physics.cast({
        origin    = { x = -150, y = 50, z = 120 },
        direction = { x = 0, y = -1, z = 0 },
        type      = 3,
        size      = { x = 20, y = 100, z = 20 },
    })
    for _, hit in ipairs(stagingHits) do
        local obj = hit.hit_object
        if obj and obj.tag == "Deck" and obj.getName() == "Strain Rewards" then
            obj.destruct()
        end
    end

    Archive.containers = {}
    Archive.containerX = -150
    Archive.containerZ = 120
end

---------------------------------------------------------------------------------------------------
-- Helper for transferring cards between decks with proper async handling
-- Used by FightingArtsArchive, VerminArchive, BasicResourcesArchive
---------------------------------------------------------------------------------------------------

function Archive.TransferCard(params)
    -- params:
    --   source: deck to take card from
    --   target: deck to put card into
    --   cardIndex: index of card in source deck
    --   archive: (optional) infinite archive to return target deck to
    --   deckLocation: (optional) location name for Deck.ResetDeck
    --   logMessage: (optional) message to log on completion
    --   onComplete: (optional) callback when operation completes

    local Deck = require("Kdm/Deck")
    
    params.source.takeObject({
        index = params.cardIndex,
        position = params.target.getPosition(),
        smooth = false,
        callback_function = function(card)
            local function complete()
                params.target.putObject(card)
                card.destruct()
                if params.archive then
                    if params.archive.reset then
                        params.archive.reset()
                    end
                    params.archive.putObject(params.target)
                end
                Archive.Clean()
                if params.deckLocation then
                    Deck.ResetDeck(params.deckLocation)
                end
                if params.logMessage then
                    log:Printf(params.logMessage)
                end
                if params.onComplete then
                    params.onComplete()
                end
            end
            Wait.condition(complete, function() return card.resting end, 5, complete)
        end,
    })
end

---------------------------------------------------------------------------------------------------
-- Helper for removing and destroying a card from a deck with proper async handling
---------------------------------------------------------------------------------------------------

function Archive.RemoveAndDestroyCard(params)
    -- params:
    --   deck: deck to remove card from
    --   cardIndex: index of card in deck
    --   archive: (optional) infinite archive to return deck to
    --   deckLocation: (optional) location name for Deck.ResetDeck
    --   logMessage: (optional) message to log on completion
    --   onComplete: (optional) callback when operation completes

    local Deck = require("Kdm/Deck")
    
    params.deck.takeObject({
        index = params.cardIndex,
        smooth = false,
        callback_function = function(card)
            local function complete()
                if card then
                    card.destruct()
                end
                if params.archive then
                    if params.archive.reset then
                        params.archive.reset()
                    end
                    params.archive.putObject(params.deck)
                end
                Archive.Clean()
                if params.deckLocation then
                    Deck.ResetDeck(params.deckLocation)
                end
                if params.logMessage then
                    log:Printf(params.logMessage)
                end
                if params.onComplete then
                    params.onComplete()
                end
            end
            Wait.condition(complete, function() return card == nil or card.resting end, 5, complete)
        end,
    })
end

---------------------------------------------------------------------------------------------------
-- High-level helper for transferring a card from one deck to another
-- Used by archive modules (DisordersArchive, SevereInjuriesArchive, StrangeResourcesArchive)
---------------------------------------------------------------------------------------------------

function Archive.TransferCardBetweenDecks(params)
    -- params:
    --   sourceDeckName: name of source deck (e.g., "Strain Rewards")
    --   sourceDeckType: type of source deck (e.g., "Rewards")
    --   targetArchiveName: name of target archive (e.g., "Disorders Archive")
    --   targetDeckLocation: location name for Deck.ResetDeck (e.g., "Disorders")
    --   stagingPosition: position for staging decks during transfer
    --   cardName: name of card to transfer
    --   cardType: GMNotes type to match (e.g., "Disorders")
    --   logMessage: message to log on success
    --   onComplete: (optional) callback when operation completes
    
    assert(Check.Str(params.sourceDeckName, "sourceDeckName required"))
    assert(Check.Str(params.targetArchiveName, "targetArchiveName required"))
    assert(Check.Str(params.cardName, "cardName required"))
    assert(Check.Str(params.cardType, "cardType required"))
    
    local stagingPos = params.stagingPosition or { x = -150, y = 15, z = 120 }
    
    -- Take target deck from its archive
    local targetArchive = NamedObject.Get(params.targetArchiveName)
    if not targetArchive then
        log:Errorf("Archive '%s' not found.", params.targetArchiveName)
        return false
    end
    
    local targetDeck = targetArchive.takeObject({
        position = stagingPos,
        rotation = { x = 0, y = 180, z = 180 },
        smooth = false,
    })
    if not targetDeck then
        log:Errorf("Unable to take deck from archive '%s'.", params.targetArchiveName)
        return false
    end
    
    -- Take source deck
    local sourceDeck = Archive.Take({
        name = params.sourceDeckName,
        type = params.sourceDeckType,
        position = {
            x = stagingPos.x + 5,
            y = stagingPos.y,
            z = stagingPos.z,
        },
        rotation = { x = 0, y = 180, z = 180 },
    })
    if not sourceDeck then
        log:Errorf("Unable to take '%s' deck from archive.", params.sourceDeckName)
        targetArchive.putObject(targetDeck)
        Archive.Clean()
        return false
    end
    
    -- Find card in source deck
    local cardIndex
    for _, obj in ipairs(sourceDeck.getObjects()) do
        if obj.name == params.cardName and obj.gm_notes == params.cardType then
            cardIndex = obj.index
            break
        end
    end
    
    if not cardIndex then
        log:Errorf("Card '%s' not found in '%s' deck.", params.cardName, params.sourceDeckName)
        targetArchive.putObject(targetDeck)
        Archive.Clean()
        return false
    end
    
    -- Transfer the card
    Archive.TransferCard({
        source = sourceDeck,
        target = targetDeck,
        cardIndex = cardIndex,
        archive = targetArchive,
        deckLocation = params.targetDeckLocation,
        logMessage = params.logMessage,
        onComplete = params.onComplete,
    })
    
    return true
end

---------------------------------------------------------------------------------------------------
-- High-level helper for removing a card from a deck
-- Used by archive modules (DisordersArchive, SevereInjuriesArchive, StrangeResourcesArchive)
---------------------------------------------------------------------------------------------------

function Archive.RemoveCardFromDeck(params)
    -- params:
    --   archiveName: name of archive containing the deck
    --   deckLocation: location name for Deck.ResetDeck
    --   stagingPosition: position for staging deck
    --   cardName: name of card to remove
    --   cardType: GMNotes type to match
    --   logMessage: message to log on success
    --   onComplete: (optional) callback when operation completes
    
    assert(Check.Str(params.archiveName, "archiveName required"))
    assert(Check.Str(params.cardName, "cardName required"))
    assert(Check.Str(params.cardType, "cardType required"))
    
    local stagingPos = params.stagingPosition or { x = -150, y = 15, z = 120 }
    
    -- Take deck from archive
    local archive = NamedObject.Get(params.archiveName)
    if not archive then
        log:Errorf("Archive '%s' not found.", params.archiveName)
        return false
    end
    
    local deck = archive.takeObject({
        position = stagingPos,
        rotation = { x = 0, y = 180, z = 180 },
        smooth = false,
    })
    if not deck then
        log:Errorf("Unable to take deck from archive '%s'.", params.archiveName)
        return false
    end
    
    -- Find card in deck
    local cardIndex
    for _, obj in ipairs(deck.getObjects()) do
        if obj.name == params.cardName and obj.gm_notes == params.cardType then
            cardIndex = obj.index
            break
        end
    end
    
    if not cardIndex then
        archive.putObject(deck)
        log:Debugf("%s not present in deck.", params.cardName)
        return false
    end
    
    -- Remove and destroy the card
    Archive.RemoveAndDestroyCard({
        deck = deck,
        cardIndex = cardIndex,
        archive = archive,
        deckLocation = params.deckLocation,
        logMessage = params.logMessage,
        onComplete = params.onComplete,
    })
    
    return true
end

---------------------------------------------------------------------------------------------------

return {
    Init = Archive.Init,
    RegisterEntries = Archive.RegisterEntries,
    Take = Archive.Take,
    TakeObject = Archive.TakeObject,
    TakeFromDeck = Archive.TakeFromDeck,
    ArchiveSource = Archive.ArchiveSource,
    ContainerSource = Archive.ContainerSource,
    CreateDeckFromSources = Archive.CreateDeckFromSources,
    Clean = Archive.Clean,
    CreateAllGearDeck = Archive.CreateAllGearDeck,
    TransferCard = Archive.TransferCard,
    RemoveAndDestroyCard = Archive.RemoveAndDestroyCard,
    TransferCardBetweenDecks = Archive.TransferCardBetweenDecks,
    RemoveCardFromDeck = Archive.RemoveCardFromDeck,
    
    -- Test seam exports
    Test_SetSpawner = Archive.Test_SetSpawner,
    Test_ResetSpawner = Archive.Test_ResetSpawner,
    Test_Key = Archive.Key,
    Test_RegisterIndexEntry = Archive.RegisterIndexEntry,
}
